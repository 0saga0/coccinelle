\documentclass{article}
\usepackage{hevea}
\usepackage{fullpage}
\usepackage{alltt}
\usepackage{xspace}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage[T1]{fontenc}

\lstset{basicstyle=\ttfamily,numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt,language=C,commentstyle=\color{OliveGreen},keywordstyle=\color{blue},stringstyle=\color{BrickRed}}

% You must prefix the +/- lines of
% cocci files with @+/@- respectively.
% This will enable the automatic coloration.
\ifhevea
\lstdefinelanguage{Cocci}{
morekeywords={when,strict,any,forall,exists},
keywordstyle=\color{Bittersweet}\bfseries,
sensitive=false
}
\else
\lstdefinelanguage{Cocci}{
morekeywords={idexpression,expression,statement,identifier,
parameter,list,when,strict,any,forall,exists},
keywordstyle=\color{Bittersweet}\bfseries,
sensitive=false,
morecomment=*[s][\color{OliveGreen}]{@}{@@},
morecomment=*[s][\color{OliveGreen}]{@@}{@@},
moredelim=[il][\color{blue}]{@+},
moredelim=[il][\color{BrickRed}]{@-}
}
\fi

\newif\iflanguagestyle
\languagestylefalse
\input{grammar}

\newcommand{\sizecodebis}[0]{\scriptsize}

\newcommand{\mita}[1]{\mbox{\it{{#1}}}}
\newcommand{\mtt}[1]{\mbox{\tt{{#1}}}}
\newcommand{\msf}[1]{\mbox{\sf{{#1}}}}
\newcommand{\stt}[1]{\mbox{\scriptsize\tt{{#1}}}}
\newcommand{\ssf}[1]{\mbox{\scriptsize\sf{{#1}}}}
\newcommand{\sita}[1]{\mbox{\scriptsize\it{{#1}}}}
\newcommand{\mrm}[1]{\mbox{\rm{{#1}}}}
\newcommand{\mth}[1]{\({#1}\)}
\newcommand{\entails}[2]{\begin{array}{@{}c@{}}{#1}\\\hline{#2}\end{array}}
\newcommand{\ttlb}{\mbox{\tt \char'173}}
\newcommand{\ttrb}{\mbox{\tt \char'175}}
\newcommand{\ttmid}{\mbox{\tt \char'174}}
\newcommand{\tttld}{\mbox{\tt \char'176}}

\newcommand{\fixme}[1]{{\color{red} #1}}

\ifhevea
\newcommand{\phantom}{}
\newcommand{\air}{   }
\else
\newcommand{\air}{\phantom{xxx}}
\fi

\title{The SmPL Grammar}
\author{Research group on Coccinelle}
\date{\today}

\begin{document}
\maketitle

%\section{The SmPL Grammar}

% This section presents the SmPL grammar.  This definition follows closely
% our implementation using the Menhir parser generator \cite{menhir}.

The grammar uses some rules where the left-hand side is in all capital
letters.  These are macros, which take one or more grammar rule
right-hand-sides as arguments.  The grammar also uses some unspecified
nonterminals, such as {\sf id}, {\sf const}, etc.  These refer to the
sets suggested by the name, {\em i.e.}, {\sf id} refers to the set of
possible C-language identifiers, while {\sf const} refers to the set
of possible C-language constants. \ifhevea A PDF version of this
documention is available at
\url{http://localhost:8080/coccinelle/cocci_syntax.pdf}.  \fi

\section{Program}

\begin{grammar}
  \RULE{\rt{program}}
  \CASE{\any{\NT{include}} \some{\NT{changeset}}}

  \RULE{\rt{include}}
  \CASE{using "\NT{string}"}
  \CASE{using <\NT{pathToIsoFile}>}

  \RULE{\rt{changeset}}
  \CASE{\NT{metavariables} \ANY{--- filename +++ filename} \NT{transformation}}

\end{grammar}

Between the metavariables and the transformation rule, there can be a
specification of constraints on the names of the old and new files,
analogous to the filename specifications in the standard patch syntax.
%(see Figure \ref{scsiglue_patch}).

\section{Metavariables}

Fresh metavariables must only be used in {\tt +} code.  Metavariables must
occur at least once in the transformation immediately following their
declaration.  These properties are not expressed in the grammar, but are
checked by a subsequent analysis.

\begin{grammar}
  \RULE{\rt{metavariables}}
  \CASE{@@ \any{\NT{metadecl}} @@}
  \CASE{@ \NT{rulename} @ \any{\NT{metadecl}} @@}

  \RULE{\rt{rulename}}
  \CASE{\T{id} \OPT{extends \T{id}} \OPT{depends on \NT{dep}} \opt{\NT{iso}} \opt{\NT{disable}} \opt{\NT{exists}} \opt{expression}}
  \CASE{script:\T{language} \OPT{depends on \NT{dep}}}

  \RULE{\rt{dep}}
  \CASE{\NT{pnrule}}
  \CASE{\NT{dep} \&\& \NT{dep}}
  \CASE{\NT{dep} || \NT{dep}}

  \RULE{\rt{pnrule}}
  \CASE{\T{id}}
  \CASE{!\T{id}}
  \CASE{ever \T{id}}
  \CASE{never \T{id}}
  \CASE{(\NT{dep})}

  \RULE{\rt{iso}}
  \CASE{using "\T{str}" \ANY{, "\T{str}"}}

  \RULE{\rt{disable}}
  \CASE{disable \T{id} \ANY{, \T{id}}}

  \RULE{\rt{exists}}
  \CASE{exists}
  \CASE{\opt{reverse} forall}
\end{grammar}

\begin{grammar}
  \RULE{\rt{metadecl}}
  \CASE{fresh identifier \NT{ids} ;}
  \CASE{parameter \opt{list} \NT{ids} ;}
  \CASE{expression list \NT{ids} ;}
  \CASE{type \NT{ids} ;}
  \CASE{statement \opt{list} \NT{ids} ;}
  \CASE{typedef \NT{ids} ;}
  \CASE{declarer name \NT{ids} ;}
  \CASE{iterator name \NT{ids} ;}
  \CASE{identifier \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{\opt{local} function \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{declarer \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{iterator \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{error \NT{pmid\_with\_not\_eq\_list} ; }
  \CASE{\opt{local} idexpression \opt{\NT{ctype}} \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{\opt{local} idexpression \OPT{\ttlb \NT{ctypes} \ttrb \any{*}} \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{\opt{local} idexpression \some{*} \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{expression \some{*} \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{\NT{ctype} [ ] \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{\ttlb \NT{ctypes} \ttrb \any{*} [ ] \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{constant \opt{\NT{ctype}} \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{constant \OPT{\ttlb \NT{ctypes} \ttrb \any{*}} \NT{pmid\_with\_not\_eq\_list} ;}
  \CASE{expression \NT{pmid\_with\_not\_ceq\_list} ;}
  \CASE{\NT{ctype} \NT{pmid\_with\_not\_ceq\_list} ;}
  \CASE{\ttlb \NT{ctypes} \ttrb \any{*} \NT{pmid\_with\_not\_ceq\_list} ;}
  \CASE{position \opt{any} \NT{pmid\_with\_not\_eq\_mid\_list} ;}
  \CASE{parameter list [ ident ] \NT{ids} ;}
  \CASE{expression list [ ident ] \NT{ids} ;}
\end{grammar}

\begin{grammar}
  \RULE{\rt{ids}}
  \CASE{\NT{pmid} \ANY{, \NT{pmid}}}

  \RULE{\rt{pmid}}
  \CASE{\T{id}}
  \CASE{\NT{mid}}
  \CASE{list}
  \CASE{error}
  \CASE{type}

  \RULE{\rt{mid}}  \CASE{\T{rulename\_id}.\T{id}}

  \RULE{\rt{pmid\_with\_not\_eq\_list}}
  \CASE{\NT{pmid\_with\_not\_eq} \ANY{, \NT{pmid\_with\_not\_eq}}}

  \RULE{\rt{pmid\_with\_not\_eq}}
  \CASE{\NT{pmid} \OPT{!= \T{id}}}
  \CASE{\NT{pmid} \OPT{!= \ttlb \T{id} \ANY{, \T{id}} \ttrb}}

  \RULE{\rt{pmid\_with\_not\_ceq\_list}}
  \CASE{\NT{pmid\_with\_not\_ceq} \ANY{, \NT{pmid\_with\_not\_ceq}}}

  \RULE{\rt{pmid\_with\_not\_ceq}}
  \CASE{\NT{pmid} \OPT{!= \NT{id\_or\_cst}}}
  \CASE{\NT{pmid} \OPT{!= \ttlb \NT{id\_or\_cst} \ANY{, \NT{id\_or\_cst}} \ttrb}}

  \RULE{\rt{id\_or\_cst}}
  \CASE{\T{id}}
  \CASE{\T{integer}}

  \RULE{\rt{pmid\_with\_not\_eq\_mid\_list}}
  \CASE{\NT{pmid\_with\_not\_eq\_mid} \ANY{, \NT{pmid\_with\_not\_eq\_mid}}}

  \RULE{\rt{pmid\_with\_not\_eq\_mid}}
  \CASE{\NT{pmid} \OPT{!= \NT{mid}}}
  \CASE{\NT{pmid} \OPT{!= \ttlb \NT{mid} \ANY{, \NT{mid}} \ttrb}}
\end{grammar}

Subsequently, we refer to arbitrary metavariables as
\mth{\msf{metaid}^{\mbox{\scriptsize{\it{ty}}}}}, where {\it{ty}} indicates
the {\it metakind} used in the declaration of the variable.  For example,
\mth{\msf{metaid}^{\ssf{Type}}} refers to a metavariable that stands for
any type.

The {\it type} nonterminal is used by both the grammar of metavariable
declarations and the grammar of transformations, and is defined on
page~\pageref{types}.

\section{Transformation}

The grammar of the transformation is not actually the grammar of the SmPL
code that can be written by the programmer, but the grammar of the slice of
this consisting of the {\tt -} annotated and the unannotated code (the
context of the transformed lines), or the {\tt +} annotated code and the
unannotated code.  For example, for parsing purposes, the transformation
%presented in Section \ref{sec:seq2}
is split into the two variants shown below and each is parsed
separately.

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[language=Cocci]
  proc_info_func(...) {
    <...
@--    hostno
@++    hostptr->host_no
    ...>
 }
\end{lstlisting}\\
\end{tabular}
\end{center}

{%\sizecodebis
\begin{center}
\begin{tabular}{p{5cm}p{3cm}p{5cm}}
\begin{lstlisting}[language=Cocci]
  proc_info_func(...) {
    <...
@--    hostno
    ...>
 }
\end{lstlisting}
&&
\begin{lstlisting}[language=Cocci]
  proc_info_func(...) {
    <...
@++    hostptr->host_no
    ...>
 }
\end{lstlisting}
\end{tabular}
\end{center}
}

\noindent
Requiring that both slices parse correctly ensures that the rule matches
syntactically valid C code and that it produces syntactically valid C code.
The generated parse trees are then merged for use in the subsequent
matching and transformation process.

The grammar rule for the minus or plus slice of a transformation is as follows:

\begin{grammar}

  \RULE{\rt{transformation}}
  \CASE{\NT{fundecl}}
  \CASE{\NT{ctype}}
  \CASE{\ttlb \NT{initialize\_list} \ttrb}
  \CASE{\NT{toplevel\_seq\_start\_after\_dots\_init}}

  \RULE{\rt{toplevel\_seq\_start\_after\_dots\_init}}
  \CASE{\NT{stmt\_dots} \NT{toplevel\_after\_dots}}
  \CASE{\NT{expr} \opt{\NT{toplevel\_after\_exp}}}
  \CASE{\NT{decl\_stmt\_expr} \opt{\NT{toplevel\_after\_stmt}}}

  \RULE{\rt{stmt\_dots}}
  \CASE{... \any{\NT{whenppdecls}}}
  \CASE{<... \any{\NT{whenppdecls}} \NT{nest\_after\_dots} ...>}
  \CASE{<+... \any{\NT{whenppdecls}} \NT{nest\_after\_dots} ...+>}

  \RULE{\rt{whenppdecls}}
  \CASE{when != \NT{when\_start}$^\dag$}
  \CASE{when = \NT{rule\_elem\_stmt}$^\dag$}
  \CASE{when \NT{any\_strict} \ANY{, \NT{any\_strict}} $^\dag$}
  \CASE{when true != \NT{exp} $^\ddag$}
  \CASE{when false != \NT{exp} $^\ddag$}

  \RULE{\rt{any\_strict}}
  \CASE{any}
  \CASE{strict}
  \CASE{forall}
  \CASE{exists}

  \RULE{\rt{nest\_after\_dots}}
  \CASE{\NT{decl\_stmt\_exp} \opt{\NT{nest\_after\_stmt}}}
  \CASE{\opt{\NT{exp}} \opt{\NT{nest\_after\_exp}}}

  \RULE{\rt{nest\_after\_stmt}}
  \CASE{\NT{stmt\_dots} \NT{nest\_after\_dots}}
  \CASE{\NT{decl\_stmt} \opt{\NT{nest\_after\_stmt}}}

  \RULE{\rt{nest\_after\_exp}}
  \CASE{\NT{stmt\_dots} \NT{nest\_after\_dots}}

  \RULE{\rt{toplevel\_after\_dots}}
  \CASE{\opt{\NT{toplevel\_after\_exp}}}
  \CASE{\NT{exp} \opt{\NT{toplevel\_after\_exp}}}
  \CASE{\NT{decl\_stmt\_expr} \NT{toplevel\_after\_stmt}}

  \RULE{\rt{toplevel\_after\_exp}}
  \CASE{\NT{stmt\_dots} \opt{\NT{toplevel\_after\_dots}}}

  \RULE{\rt{decl\_stmt\_expr}}
  \CASE{TMetaStmList$^\ddag$}
  \CASE{\NT{decl\_var}}
  \CASE{\NT{stmt}}
  \CASE{(\NT{fun\_start} \ANY{| \NT{fun\_start}})}

  \RULE{\rt{toplevel\_after\_stmt}}
  \CASE{\NT{stmt\_dots} \opt{\NT{toplevel\_after\_dots}}}
  \CASE{\NT{decl\_stmt} \NT{toplevel\_after\_stmt}}

\end{grammar}

$^\dag$ Note
$^\ddag$ Check and fix me

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{transformation} & ::= &
%    \begin{tabular}[t]{@{}l}
%    \ANY{\mtt{\#include} \msf{include\_string}} \\
%    \opt{OPTDOTSEQ(\some{\mita{fun\_decl\_statement}} \(\mid\) \mita{expr},
%    \mita{stmt\_whencode})}\end{tabular} \\
% \mita{fun\_decl\_statement} & ::= & \mita{decl\_statement} \(\mid\)
% \mita{fun\_decl}
% \end{tabular}

% \begin{grammar}
%   \PRULE{OPTDOTSEQ(\NT{grammar},\NT{whencode})}
%   \CASE{\opt{... \opt{\NT{whencode}}} \NT{grammar}
%  \ANY{... \opt{\NT{whencode}} \NT{grammar}}
%  \opt{... \opt{\NT{whencode}}}}
% \end{grammar}

\noindent
Lines may be annotated with an element of the set $\{\mtt{-},
\mtt{+}\}$ or an element of the set $\{\mtt{*}, \mtt{?}\}$, or one of
each. \mtt{?} and \mtt{*} represent respectively at most one, and at
least one match of the given pattern.  There are some constraints on
the use of these annotations:
\begin{itemize}
\item Dots, {\em i.e.} \texttt{...}, cannot occur on a line marked
  \texttt{+}.
\item Nested dots, {\em i.e.} dots enclosed in {\tt <} and {\tt >}, cannot
  occur on a line with any marking.
\end{itemize}


\section{Types}
\label{types}

\begin{grammar}

  \RULE{\rt{ctypes}}
  \CASE{\NT{ctype} \ANY{, \NT{ctype}}}

  \RULE{\rt{ctype}}
  \CASE{\opt{\NT{const\_vol}} \NT{generic\_ctype} \any{*}}
  \CASE{\opt{\NT{const\_vol}} void \some{*}}
  \CASE{(\NT{ctype} \ANY{| \NT{ctype}})}

  \RULE{\rt{const\_vol}}
  \CASE{const}
  \CASE{volatile}

  \RULE{\rt{generic\_ctype}}
  \CASE{\NT{ctype\_qualif}}
  \CASE{\opt{\NT{ctype\_qualif}} char}
  \CASE{\opt{\NT{ctype\_qualif}} short}
  \CASE{\opt{\NT{ctype\_qualif}} int}
  \CASE{\opt{\NT{ctype\_qualif}} long}
  \CASE{double}
  \CASE{float}
  \CASE{\OPT{struct\OR union} \T{id} \OPT{\{ \any{\NT{struct\_decl\_list}} \}}}

  \RULE{\rt{ctype\_qualif}}
  \CASE{unsigned}
  \CASE{signed}

  \RULE{\rt{struct\_decl\_list}}
  \CASE{\NT{struct\_decl\_list\_start}}

  \RULE{\rt{struct\_decl\_list\_start}}
  \CASE{\NT{struct\_decl}}
  \CASE{\NT{struct\_decl} \NT{struct\_decl\_list\_start}}
  \CASE{... \opt{when != \NT{struct\_decl}}$^\dag$ \opt{\NT{continue\_struct\_decl\_list}}}

  \RULE{\rt{continue\_struct\_decl\_list}}
  \CASE{\NT{struct\_decl} \NT{struct\_decl\_list\_start}}
  \CASE{\NT{struct\_decl}}

  \RULE{\rt{struct\_decl}}
  \CASE{\NT{ctype} \NT{d\_ident};}
  \CASE{\NT{fn\_ctype} (* \NT{d\_ident}) (\NT{});)}
  \CASE{\opt{\NT{const\_vol}} \NT{pure\_ident} \NT{d\_ident};}

  \RULE{\rt{d\_ident}}
  \CASE{\NT{ident} \any{[\opt{\NT{eexpr}}]}}

  \RULE{\rt{fn\_ctype}}
  \CASE{\NT{generic\_ctype} \any{*}}
  \CASE{void \any{*}}
\end{grammar}

$^\dag$ The optional \texttt{when} construct ends at the end of the line.

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{type} & ::= & \opt{\mtt{const} \(\mid\) \mtt{volatile}}
%                     \mita{type\_desc} \ANY{\mtt{*}}\\
% \mita{type\_desc} & ::= & \mita{simple\_type} \(\mid\) \opt{\mtt{signed} \(\mid\)
%        \mtt{unsigned}} \mita{signable\_type} \(\mid\) \opt{\mtt{struct} \(\mid\)
%        \mtt{union}} \msf{id}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%        \mth{\msf{metaid}^{\ssf{Type}}}
% \end{tabular}}

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{simple\_type} & ::= & \mtt{void} \(\mid\) \mtt{double} \(\mid\)
%  \mtt{float} \\
% \mita{signable\_type} & ::= & \mtt{char} \(\mid\) \mtt{short} \(\mid\)
%  \mtt{int} \(\mid\) \mtt{long}
% \end{tabular}}

\section{Function declarations}

\begin{grammar}

  \RULE{\rt{fundecl}}
  \CASE{\opt{static} \NT{funid}
    (\opt{\NT{PARAMSEQ}(\NT{param},\mth{\varepsilon})})
    \ttlb~\opt{\NT{stmt\_seq}} \ttrb}

  \RULE{\rt{funid}}
  \CASE{\T{id}}
  \CASE{\mth{\T{metaid}^{\ssf{Func}}}}
  \CASE{\mth{\T{metaid}^{\ssf{LocalFunc}}}}

  \RULE{\rt{param}}
  \CASE{\NT{type} \T{id}}
  \CASE{\mth{\T{metaid}^{\ssf{Param}}}}
  \CASE{\mth{\T{metaid}^{\ssf{ParamList}}}}
\end{grammar}

\begin{grammar}
  \RULE{\rt{PARAMSEQ}(\NT{grammar},\NT{whencode})}
  \CASE{\mth{(}\NT{grammar}\OR \ldots \opt{\NT{whencode}}\mth{)} \ANY{, \NT{grammar}\OR , \ldots \opt{\NT{whencode}}}}
\end{grammar}

%\newpage

\section{Declarations}

\begin{grammar}
  \RULE{\rt{decl}}
  \CASE{\NT{type} \opt{\NT{id} \opt{[\opt{\NT{dot\_expr}}]}
      \ANY{, \NT{id} \opt{[ \opt{\NT{dot\_expr}}]}}};}
  \CASE{\NT{type} \NT{id} \opt{[\opt{\NT{dot\_expr}}]}= \NT{nest\_expr};}
\end{grammar}

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{decl\_var} & ::= &
%    \mita{type} \opt{\ANY{\mita{id} \opt{\mtt{[} \opt{\mita{dot\_expr}}
%    \mtt{]}} \mtt{,}} \mita{id} \opt{\mtt{[} \opt{\mita{dot\_expr}} \mtt{]}}}
%    \mtt{;}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%  \mita{type} \mita{id} \opt{\mtt{[} \opt{\mita{dot\_expr}} \mtt{]}}
%    \mtt{=} \mita{nest\_expr} \mtt{;}
% \end{tabular}}

\section{Statements}

The first rule {\em statement} describes the various forms of a statement.
The remaining rules implement the constraints that are sensitive to the
context in which the statement occurs: {\em single\_statement} for a
context in which only one statement is allowed, and {\em decl\_statement}
for a context in which a declaration, statement, or sequence thereof is
allowed.

%\vspace{\baselineskip}
\begin{grammar}
  \RULE{\rt{stmt}}
  \CASE{\NT{includes}}
  \CASE{\mth{\T{metaid}^{\ssf{Stmt}}}}
  \CASE{\NT{expr};}
  \CASE{if (\NT{dot\_expr}) \NT{single\_stmt} \opt{else \NT{single\_stmt}}}
  \CASE{for (\opt{\NT{dot\_expr}}; \opt{\NT{dot\_expr}}; \opt{\NT{dot\_expr}})
    \NT{single\_stmt}}
  \CASE{while (\NT{dot\_expr}) \NT{single\_stmt}}
  \CASE{do \NT{single\_stmt} while (\NT{dot\_expr});}
  \CASE{\NT{iter\_ident} (\any{\NT{dot\_expr}}) \NT{single\_stmt}}
  \CASE{switch (\opt{\NT{dot\_expr}}) \ttlb \any{\NT{case\_line}} \ttrb}
  \CASE{return \opt{\NT{dot\_expr}};}
  \CASE{\ttlb~\opt{\NT{stmt\_seq}} \ttrb}
  \CASE{\NT{NEST}(\some{\NT{decl\_stmt}}, \NT{stmt\_whencode})}
  \CASE{\NT{NEST}(\NT{expr}, \NT{stmt\_whencode})}
  \CASE{break;}
  \CASE{continue;}
  \CASE{\NT{ident}:}
  \CASE{goto \NT{ident};}
  \CASE{\ttlb \NT{fun\_start} \ttrb}

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{statement} & ::= &
%   \mth{\msf{metaid}^{\ssf{Stmt}}}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \mita{expr} \mtt{;}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \mtt{if} \mtt{(} \mita{dot\_expr} \mtt{)} \mita{single\_statement}
%   \opt{\mtt{else} \mita{single\_statement}}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \mtt{for} \mtt{(} \opt{\mita{dot\_expr}} \mtt{;} \opt{\mita{dot\_expr}} \mtt{;}
%   \opt{\mita{dot\_expr}} \mtt{)} \mita{single\_statement}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \mtt{while} \mtt{(} \mita{dot\_expr} \mtt{)} \mita{single\_statement}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \mtt{do} \mita{single\_statement} \mtt{while} \mtt{(} \mita{dot\_expr} \mtt{)}
%   \mtt{;}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \mtt{return} \opt{\mita{dot\_expr}} \mtt{;}
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   \ttlb~\opt{\mita{statement\_sequence}} \ttrb
% \\&\multicolumn{1}{r}{\(\mid\)}&
%   NEST(\some{\mita{decl\_statement}} \(\mid\) \mita{expr}, \mita{stmt\_whencode})
% \end{tabular}}

  \RULE{\rt{single\_stmt}}
  \CASE{\NT{stmt}}
  \CASE{\NT{OR}(\NT{stmt})}

  \RULE{\rt{decl\_stmt}}
  \CASE{\mth{\T{metaid}^{\ssf{StmtList}}}}
  \CASE{\NT{decl\_var}}
  \CASE{\NT{stmt}}
  \CASE{\NT{OR}(\NT{stmt\_seq})}

  \RULE{\rt{stmt\_seq}}
  \CASE{\any{\NT{decl\_stmt}}
    \opt{\NT{DOTSEQ}(\some{\NT{decl\_stmt}},
      \NT{stmt\_whencode}) \any{\NT{decl\_stmt}}}}
  \CASE{\any{\NT{decl\_stmt}}
    \opt{\NT{DOTSEQ}(\NT{expr},
      \NT{stmt\_whencode}) \any{\NT{decl\_stmt}}}}

  \RULE{\rt{stmt\_whencode}}
  \CASE{when != \NT{XXXDOTSEQXXX}(\some{\NT{decl\_stmt}}, \NT{stmt\_whencode})}
  \CASE{when != \NT{XXXDOTSEQXXX}(\NT{expr}, \NT{stmt\_whencode})}

  \RULE{\rt{case\_line}}
  \CASE{default : \NT{fun\_start}}
  \CASE{case \NT{dot\_expr} : \NT{fun\_start}}

  \RULE{\rt{fun\_start}}
  \CASE{}

  \RULE{\rt{iter\_ident}}
  \CASE{\T{IteratorId}}
  \CASE{\T{MetaIterator}}
\end{grammar}

\noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{single\_statement} & ::= &
%      \mita{statement} \(\mid\) OR(\mita{statement})
% \\
% \mita{decl\_statement} & ::= &
%   \mth{\msf{metaid}^{\ssf{StmtList}}} \(\mid\)
%   \mita{decl\_var} \(\mid\) \mita{statement} \(\mid\)
%   OR(\mita{statement\_sequence})
% \\
% \mita{statement\_sequence} & ::= &\\
%   \multicolumn{3}{r}{\air\air\any{\mita{decl\_statement}}
%   \opt{DOTSEQ(\some{\mita{decl\_statement}} \(\mid\) \mita{expr},
%   \mita{stmt\_whencode}) \any{\mita{decl\_statement}}}}
% \\
\mita{stmt\_whencode} & ::= & \mtt{WHEN} \mtt{!=}
OPTDOTSEQ(\some{\mita{decl\_statement}} \(\mid\) \mita{expr},\mita{stmt\_whencode})
% \\
% OR(\mita{grammar}) & ::= &
%  \mtt{(} \mita{grammar} \ANY{\ttmid \mita{grammar}} \mtt{)}
\end{tabular}}

\begin{grammar}
  \RULE{\rt{OR}(\NT{grammar})}
  \CASE{( \NT{grammar} \ANY{\ttmid \NT{grammar}})}

  \RULE{\rt{DOTSEQ}(\NT{grammar},\NT{whencode})}
  \CASE{\ldots \opt{\NT{whencode}} \ANY{\NT{grammar} \ldots \opt{\NT{whencode}}}}

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% DOTSEQ(\mita{grammar},\mita{whencode}) & ::= &
% \\ \multicolumn{3}{l}{\air\air\phantom{\(\mid\)}
%  \mtt{\ldots} \opt{\mita{whencode}} \ANY{\mita{grammar} \mtt{\ldots}
%  \opt{\mita{whencode}}}}
% \\ \multicolumn{3}{l}{\air\air\(\mid\)
%  \mtt{ooo} \opt{\mita{whencode}} \ANY{\mita{grammar} \mtt{ooo}
%  \opt{\mita{whencode}}}}
% \\ \multicolumn{3}{l}{\air\air\(\mid\)
%  \mtt{***} \opt{\mita{whencode}} \ANY{\mita{grammar} \mtt{***}
%  \opt{\mita{whencode}}}}
% \end{tabular}}

  \RULE{\rt{NEST}(\NT{grammar},\NT{whencode})}
  \CASE{<\ldots \NT{grammar} \ANY{\ldots \opt{\NT{whencode}} \NT{grammar}} \ldots>}
  \CASE{<+\ldots \NT{grammar} \ANY{\ldots \opt{\NT{whencode}} \NT{grammar}} \ldots+>}

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% NEST(\mita{grammar},\mita{whencode}) & ::= &
% \\ \multicolumn{3}{l}{\air\air\phantom{\(\mid\)}
%  \mtt{<\ldots} \mita{grammar} \ANY{\ldots \opt{\mita{whencode}}
%  \mita{grammar}} \mtt{\ldots>}}
% \\ \multicolumn{3}{l}{\air\air\(\mid\)
%  \mtt{<ooo} \mita{grammar} \ANY{ooo \opt{\mita{whencode}} \mita{grammar}}
%  \mtt{ooo>}}
% \\ \multicolumn{3}{l}{\air\air\(\mid\)
%  \mtt{<***} \mita{grammar} \ANY{*** \opt{\mita{whencode}} \mita{grammar}}
%  \mtt{***>}}
% \end{tabular}}

\end{grammar}

%\vspace{\baselineskip}

\noindent
OR is a macro that generates a disjunction of patterns.  The three
tokens \T{(}, \T{\ttmid}, and \T{)} must appear in the leftmost
column, to differentiate them from the parentheses and bit-or tokens
that can appear within expressions (and cannot appear in the leftmost
column).  These tokens are furthermore different from (, \(\mid\), and
), which are part of the grammar metalanguage.

\section{Expressions}

A nest or a single ellipsis is allowed in some expression contexts, and
causes ambiguity in others.  For example, in a sequence \mtt{\ldots
\mita{expr} \ldots}, the nonterminal \mita{expr} must be instantiated as an
explicit C-language expression, while in an array reference,
\mtt{\mth{\mita{expr}_1} \mtt{[} \mth{\mita{expr}_2} \mtt{]}}, the
nonterminal \mth{\mita{expr}_2}, because it is delimited by brackets, can
be also instantiated as \mtt{\ldots}, representing an arbitrary expression.  To
distinguish between the various possibilities, we define three nonterminals
for expressions: {\em expr} does not allow either top-level nests or
ellipses, {\em nest\_expr} allows a nest but not an ellipsis, and {\em
dot\_expr} allows both.  The EXPR macro is used to express these variants
in a concise way.

%\vspace{\baselineskip}
\begin{grammar}
  \RULE{\rt{expr}}
  \CASE{\NT{EXPR}(\NT{expr})}

  \RULE{\rt{nest\_expr}}
  \CASE{\NT{EXPR}(\NT{nest\_expr})}
  \CASE{\NT{NEST}(\NT{nest\_expr}, \NT{exp\_whencode})}

  \RULE{\rt{dot\_expr}}
  \CASE{\NT{EXPR}(\NT{dot\_expr})}
  \CASE{\NT{NEST}(\NT{dot\_expr}, \NT{exp\_whencode})}
  \CASE{... \opt{\NT{exp\_whencode}}}

  \RULE{\rt{EXPR}(exp)}
  \CASE{\NT{exp} \NT{assign\_op} \NT{exp}}
  \CASE{\NT{exp}++}
  \CASE{\NT{exp}--}
  \CASE{\NT{unary\_op} \NT{exp}}
  \CASE{\NT{exp} \NT{bin\_op} \NT{exp}}
  \CASE{\NT{exp} ? \NT{dot\_expr} : \NT{exp}}
  \CASE{(\NT{type}) \NT{exp}}
  \CASE{\NT{exp} [\NT{dot\_expr}]}
  \CASE{\NT{exp} . \NT{id}}
  \CASE{\NT{exp} -> \NT{id}}
  \CASE{\NT{exp}(\opt{\NT{PARAMSEQ}(\NT{arg}, \NT{exp\_whencode})})}
  \CASE{\NT{id}}
  \CASE{\mth{\T{metaid}^{\ssf{Func}}}}
  \CASE{\mth{\T{metaid}^{\ssf{LocalFunc}}}}
  \CASE{\mth{\T{metaid}^{\ssf{Exp}}}}
  \CASE{\mth{\T{metaid}^{\ssf{Err}}}}
  \CASE{\mth{\T{metaid}^{\ssf{Const}}}}
  \CASE{\NT{const}}
  \CASE{(\NT{dot\_expr})}
  \CASE{\NT{OR}(\NT{exp})}

  \RULE{\rt{arg}}
  \CASE{\NT{nest\_expr}}
  \CASE{\mth{\T{metaid}^{\ssf{ExpList}}}}

  \RULE{\rt{exp\_whencode}}
  \CASE{when != \NT{dot\_expr}}

  \RULE{\rt{assign\_op}}
  \CASE{= \OR -= \OR += \OR *= \OR /= \OR \%=}
  \CASE{\&= \OR |= \OR \caret= \OR \lt\lt= \OR \gt\gt=}

  \RULE{\rt{bin\_op}}
  \CASE{* \OR / \OR \% \OR + \OR -}
  \CASE{\lt\lt \OR \gt\gt \OR \caret\xspace \OR \& \OR \ttmid}
  \CASE{< \OR > \OR <= \OR >= \OR == \OR != \OR \&\& \OR \ttmid\ttmid}

  \RULE{\rt{unary\_op}}
  \CASE{++ \OR -- \OR \& \OR * \OR + \OR - \OR !}

\end{grammar}

\section{Constant, Identifiers and Types for Transformations}

\begin{grammar}
  \RULE{const}
  \CASE{"\any{[\^{}"]}"}
  \CASE{[0-9]+}
  \CASE{\mth{\cdots}}

  \RULE{id}
  \CASE{\T{id} \OR \mth{\T{metaid}^{\ssf{Id}}}}

  \RULE{type}
  \CASE{\NT{ctype} \OR \mth{\T{metaid}^{\ssf{Type}}}}
\end{grammar}

% \noindent{\footnotesize\begin{tabular}{r@{\,\,\,}c@{\,\,\,}l}
% \mita{id} & ::= & \msf{id} \(\mid\) \mth{\msf{metaid}^{\ssf{Id}}}
% \end{tabular}}

\include{examples}
\end{document}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "cocci_syntax"
%%% coding: latin-9
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:

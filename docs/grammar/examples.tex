
\section{Examples}
%\label{sec:examples}

We provide some real or reallistic examples in the following section.
Each example is detailled with some C code on which it is applied. The
description explains the matching process and when applicable the
rewriting rules.

\subsection{Function renaming}

One of the primary goal of Coccinelle is to perform software
evolution.  For instance, Coccinelle could be used to perform function
renaming. In the following example, every occurrence of a function
call \texttt{foo} is replaced by a call to the \texttt{bar} function.\\

\begin{tabular}{ccc}
Before & Semantic patch & After \\
\begin{minipage}[t]{.3\linewidth}
\begin{lstlisting}
#DEFINE TEST "foo"

printf("foo");

int main(int i) {
//Test
  int k = foo();

  if(1) {
    foo();
  } else {
    foo();
  }

  foo();
}
\end{lstlisting}
\end{minipage}
&
\begin{minipage}[t]{.3\linewidth}
\begin{lstlisting}[language=Cocci]
@M@@

@@@M


@-- foo()
@++ bar()
\end{lstlisting}
\end{minipage}
&
\begin{minipage}[t]{.3\linewidth}
\begin{lstlisting}
#DEFINE TEST "foo"

printf("foo");

int main(int i) {
//Test
  int k = bar();

  if(1) {
    bar();
  } else {
    bar();
  }

  bar();
}
\end{lstlisting}
\end{minipage}\\
\end{tabular}

\newpage
\subsection{Removing a function argument}

Another important kind of evolution is the introduction or deletion of
a function argument. In the following example, the \texttt{rule1} rule
looks for functions of type \texttt{irqreturn\_t} with two
arguments. A second \emph{anonymous} rule, then looks for calls of the
previously matched functions which provides three arguments. The third
argument is then removed to correspond to the new function prototype.\\

\begin{tabular}{c}
\begin{lstlisting}[language=Cocci,name=arg]
@M@ rule1 @
identifier fn;
identifier irq, dev_id;
typedef irqreturn_t;
@@@M

static irqreturn_t fn (int irq, void *dev_id)
{
   ...
}

@M@@
identifier rule1.fn;
expression E1, E2, E3;
@@@M

 fn(E1, E2
@--  ,E3
   )
\end{lstlisting}\\
\end{tabular}

\vspace{1cm}

\begin{tabular}{c}
  \texttt{/drivers/atm/firestream.c} at line 1653 before\\
\begin{lstlisting}[language=PatchC]
static void fs_poll (unsigned long data)
{
        struct fs_dev *dev = (struct fs_dev *) data;

        fs_irq (0, dev, NULL);
        dev->timer.expires = jiffies + FS_POLL_FREQ;
        add_timer (&dev->timer);
}
\end{lstlisting}\\
\vspace{1cm}
\\


  \texttt{/drivers/atm/firestream.c} at line 1653 after\\
\begin{lstlisting}[language=PatchC]
static void fs_poll (unsigned long data)
{
        struct fs_dev *dev = (struct fs_dev *) data;

@-        fs_irq (0, dev);
        dev->timer.expires = jiffies + FS_POLL_FREQ;
        add_timer (&dev->timer);
}
\end{lstlisting}\\
\end{tabular}

\newpage
\subsection{Introduction of a macro}

To avoid code duplication or error prone code, macros or functions are
introduced such as \texttt{BUG\_ON}, \texttt{DIV\_ROUND\_UP} or
\texttt{FIELD\_SIZE}. In these cases, the semantic patches look for the
old code pattern and replace it by the new code.

For instance, the \texttt{BUG\_ON} macro enables to place some
assertion on expressions. However, the \texttt{BUG\_ON} macro could
not be used when the asserted expression may have some side-effects,
such as a function call, as a macro may evaluate more than once theirs
arguments.\\

\begin{tabular}{c}
\begin{lstlisting}[language=Cocci,name=bugon]
@M@@
expression E,f;
@@@M

(
  if (<... f(...) ...>) { BUG(); }
|
@-- if (E) { BUG(); }
@++ BUG_ON(E);
)

@M@ disable unlikely @
expression E,f;
@@@M

(
  if (<... f(...) ...>) { BUG(); }
|
@-- if (unlikely(E)) { BUG(); }
@++ BUG_ON(E);
)
\end{lstlisting}\\
\end{tabular}\\

{\color{red} To avoid miss interpretation of the \texttt{unlikely}
  construction, its corresponding isomorphism is desactivated to find
  more sites where the rewriting rule may apply.\\}


For instance, with the previously shown example, Coccinelle generates
patches like the following one.

\begin{tabular}{c}
\begin{lstlisting}[language=PatchC]
@---- a/fs/ext3/balloc.c
@++++ b/fs/ext3/balloc.c
@@ -232,8 +232,7 @@ restart:
                prev = rsv;
        }
        printk("Window map complete.\n");
@--       if (bad)
@--               BUG();
@++       BUG_ON(bad);
 }
 #define rsv_window_dump(root, verbose) \
        __rsv_window_dump((root), (verbose), __FUNCTION__)
\end{lstlisting}
\end{tabular}

\newpage
\subsection{Look for \texttt{NULL} dereference}

This SmPL match looks for \texttt{NULL} dereferences. Once an
expression has been compared to \texttt{NULL}, a dereference to this
expression is prohibited unless the pointer variable is reaffected.\\

\begin{tabular}{c}
    Original \\

\begin{lstlisting}
foo = kmalloc(1024);
if (!foo) {
  printk ("Error %s", foo->here);
  return;
}
foo->ok = 1;
return;
\end{lstlisting}\\
  \end{tabular}

\vspace{1cm}

\begin{tabular}{c}
  Semantic match\\

\begin{lstlisting}[language=Cocci]
@M@@
expression E, E1;
identifier f;
statement S1,S2,S3;
@@@M

@+* if (E == NULL)
{
  ... when != if (E == NULL) S1 else S2
      when != E = E1
@+* E->f
  ... when any
  return ...;
}
else S3
\end{lstlisting}\\
\end{tabular}

\vspace{1cm}

\begin{tabular}{c}
  Matched lines\\

\begin{lstlisting}[language=PatchC]
foo = kmalloc(1024);
@-if (!foo) {
@-  printk ("Error %s", foo->here);
  return;
}
foo->ok = 1;
return;
\end{lstlisting}\\
\end{tabular}

\newpage
\subsection{Reference counter: the of\_xxx API}

Coccinelle could be used in conjunction with Python. Python code is
used inside special SmPL rule annoted with \texttt{script:python}.
Python rules inherit metavariables, such as identifier or token
positions, from other SmPL rules. The inherited metavariables could
then be manipulated by Python code.

The following semantic match looks for a call to the
\texttt{of\_find\_node\_by\_name} function. This call increment a
counter which must be decremented to release the resource. Then,
\texttt{when} there is no call to \texttt{of\_node\_put}, no new
affectation to the \texttt{device\_node} variable \texttt{n} and a
\texttt{return} statement is reached, a bug is detected and the
position \texttt{p1} and \texttt{p2} are initiliazed. As the python
only depends on these two position, it is evaluated. In the following
case, some emacs Org mode data are produced.

\begin{tabular}{c}
\begin{lstlisting}[language=Cocci,breaklines=true]
@M@ r exists @
local idexpression struct device_node *n;
position p1, p2;
statement S1,S2;
expression E,E1;
@@@M

(
if (!(n@p1 = of_find_node_by_name(...))) S1
|
n@p1 = of_find_node_by_name(...)
)
<... when != of_node_put(n)
    when != if (...) { <+... of_node_put(n) ...+> }
    when != true !n  || ...
    when != n = E
    when != E = n
if (!n || ...) S2
...>
(
  return <+...n...+>;
|
return@p2 ...;
|
n = E1
|
E1 = n
)

@M@ script:python @
p1 << r.p1;
p2 << r.p2;
@@@M

print "* TODO [[view:%s::face=ovl-face1::linb=%s::colb=%s::cole=%s][inc. counter:%s::%s]]" % (p1[0].file,p1[0].line,p1[0].column,p1[0].column_end,p1[0].file,p1[0].line)
print "[[view:%s::face=ovl-face2::linb=%s::colb=%s::cole=%s][return]]" % (p2[0].file,p2[0].line,p2[0].column,p2[0].column_end)
\end{lstlisting}
\end{tabular}


{\newpage\color{red} Nested dots must be explained.}

The previously semantic match has been used to generate the following
lines. They may be edited using the emacs Org mode to navigate in the code
from a site to another.

\begin{lstlisting}[breaklines=true]
* TODO [[view:/linux-next/arch/powerpc/platforms/pseries/setup.c::face=ovl-face1::linb=236::colb=18::cole=20][inc. counter:/linux-next/arch/powerpc/platforms/pseries/setup.c::236]]
[[view:/linux-next/arch/powerpc/platforms/pseries/setup.c::face=ovl-face2::linb=250::colb=3::cole=9][return]]
* TODO [[view:/linux-next/arch/powerpc/platforms/pseries/setup.c::face=ovl-face1::linb=236::colb=18::cole=20][inc. counter:/linux-next/arch/powerpc/platforms/pseries/setup.c::236]]
[[view:/linux-next/arch/powerpc/platforms/pseries/setup.c::face=ovl-face2::linb=245::colb=3::cole=9][return]]
\end{lstlisting}

% \begin{tabular}{ccc}
% Before & Semantic patch & After \\
% \begin{minipage}[t]{.3\linewidth}
% \begin{lstlisting}
% \end{lstlisting}
% \end{minipage}
% &
% \begin{minipage}[t]{.3\linewidth}
% \begin{lstlisting}[language=Cocci]
% \end{lstlisting}
% \end{minipage}
% &
% \begin{minipage}[t]{.3\linewidth}
% \begin{lstlisting}
% \end{lstlisting}
% \end{minipage}\\
% \end{tabular}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "cocci_syntax"
%%% coding: latin-9
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "american"
%%% End:

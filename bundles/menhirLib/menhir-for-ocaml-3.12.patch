diff -Naur menhir-20171013/src/cmly_read.ml menhir-20171013-b/src/cmly_read.ml
--- menhir-20171013/src/cmly_read.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/cmly_read.ml	2018-08-31 14:45:36.174860715 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 open Cmly_format
 open Cmly_api
 
@@ -37,11 +39,11 @@
 
 let read (filename : string) : grammar =
   let ic = open_in_bin filename in
-  match read ic with
-  | x ->
+  match try Ok (read ic) with exn -> Pervasives.Error exn with
+  | Ok x ->
       close_in_noerr ic;
       x
-  | exception exn ->
+  | Pervasives.Error exn ->
       close_in_noerr ic;
       raise exn
 
diff -Naur menhir-20171013/src/Engine.ml menhir-20171013-b/src/Engine.ml
--- menhir-20171013/src/Engine.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/Engine.ml	2018-08-31 14:45:36.174860715 +0200
@@ -252,8 +252,8 @@
 
     (* This [match/with/exception] construct requires OCaml 4.02. *)
 
-    match T.semantic_action prod env with
-    | stack ->
+    match try Some (T.semantic_action prod env) with Error -> None with
+    | Some stack ->
 
         (* By our convention, the semantic action has produced an updated
            stack. The state now found in the top stack cell is the return
@@ -267,7 +267,7 @@
         let env = { env with stack; current } in
         run env false
 
-    | exception Error ->
+    | None ->
         initiate env
 
   and accept env prod =
@@ -650,8 +650,13 @@
      If desired, they could now be implemented outside Menhir, by relying on
      the functions [top] and [pop]. *)
 
-  type element =
-    | Element: 'a lr1state * 'a * position * position -> element
+  type 'b element_picker = {
+      pick_element : 'a . 'a lr1state * 'a * position * position -> 'b
+    }
+
+  type element = {
+      element : 'b . 'b element_picker -> 'b
+    }
 
   open General
 
@@ -680,12 +685,13 @@
            type-checker thinks ['a] is [semantic_value] and considers this code
            well-typed. Outside, we will use magic to provide the user with a way
            of inspecting states and recovering the value of ['a]. *)
-        let element = Element (
+        let element = {
+          element = fun picker -> picker.pick_element (
           current,
           cell.semv,
           cell.startp,
           cell.endp
-        ) in
+        ) } in
         Cons (element, stack next cell.state)
     )
 
@@ -702,7 +708,9 @@
     if next == cell then
       None
     else
-      Some (Element (env.current, cell.semv, cell.startp, cell.endp))
+      Some ({
+        element = fun picker -> picker.pick_element
+          (env.current, cell.semv, cell.startp, cell.endp)})
 
   (* [equal] compares the stacks for physical equality, and compares the
      current states via their numbers (this seems cleaner than using OCaml's
diff -Naur menhir-20171013/src/grammarFunctor.ml menhir-20171013-b/src/grammarFunctor.ml
--- menhir-20171013/src/grammarFunctor.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/grammarFunctor.ml	2018-08-31 14:45:36.174860715 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 open UnparameterizedSyntax
 open Syntax
 open Positions
diff -Naur menhir-20171013/src/grammarFunctor.mli menhir-20171013-b/src/grammarFunctor.mli
--- menhir-20171013/src/grammarFunctor.mli	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/grammarFunctor.mli	2018-08-31 14:45:36.174860715 +0200
@@ -127,7 +127,11 @@
 
 module NonterminalMap : GMap.S with type key = Nonterminal.t
 
-module NonterminalSet = NonterminalMap.Domain
+module NonterminalSet : sig
+  include module type of struct
+    include NonterminalMap.Domain
+  end
+end
 
 (* ------------------------------------------------------------------------ *)
 (* Terminals. *)
@@ -319,7 +323,7 @@
 
   (* All of the operations documented in [Map] are available. *)
 
-  include Map.S with type key = Symbol.t
+  include Stdcompat.Map.S with type key = Symbol.t
 
   val domain: 'a t -> key list
 
diff -Naur menhir-20171013/src/grammarFunctor.mli.orig menhir-20171013-b/src/grammarFunctor.mli.orig
--- menhir-20171013/src/grammarFunctor.mli.orig	1970-01-01 01:00:00.000000000 +0100
+++ menhir-20171013-b/src/grammarFunctor.mli.orig	2017-10-13 18:14:06.000000000 +0200
@@ -0,0 +1,602 @@
+(******************************************************************************)
+(*                                                                            *)
+(*                                   Menhir                                   *)
+(*                                                                            *)
+(*                       François Pottier, Inria Paris                        *)
+(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
+(*                                                                            *)
+(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
+(*  terms of the GNU General Public License version 2, as described in the    *)
+(*  file LICENSE.                                                             *)
+(*                                                                            *)
+(******************************************************************************)
+
+(* The functor [Make] transforms an abstract syntax tree for the grammar into a
+   rich internal representation of the grammar. *)
+
+(* The reason why this is now a functor, and the reason why its verbosity can
+   be controlled, is that we may wish to invoke it several times, e.g. on the
+   grammar before %inlining, and on the grammar after %inlining. 2015/11/10 *)
+
+module Make (G : sig
+
+  (* An abstract syntax tree for the grammar. *)
+  val grammar: UnparameterizedSyntax.grammar
+
+  (* This flag indicates whether it is OK to produce warnings, verbose
+     information, etc., when this functor is invoked. If it is set to
+     [false], then only serious errors can be signaled. *)
+  val verbose: bool
+
+end) : sig
+
+(* ------------------------------------------------------------------------ *)
+(* Nonterminals. *)
+
+module Nonterminal : sig
+
+  (* The type of nonterminals. *)
+
+  type t
+
+  (* Comparison. *)
+
+  val compare: t -> t -> int
+
+  (* The number of nonterminals. This includes the extra nonterminals
+     that are internally generated for the grammar's entry points. *)
+
+  val n: int
+
+  (* [lookup] maps an identifier to a nonterminal, or raises [Not_found]. *)
+
+  val lookup : string -> t
+
+  (* Nonterminals can be converted to integers. This feature is
+     exploited in the table-based back-end. *)
+
+  val n2i: t -> int
+
+  (* This produces a string representation of a nonterminal. It should
+     in principle never be applied to one of the internally generated
+     nonterminals, as we do not wish users to become aware of the
+     existence of these extra nonterminals. However, we do sometimes
+     violate this rule when it is difficult to do otherwise.
+
+     The Boolean parameter tells whether the string representation
+     should be normalized, that is, whether parentheses and commas
+     should be eliminated. This is necessary if the string is intended
+     for use as a valid nonterminal name or as a valid OCaml
+     identifier. *)
+
+  val print: bool -> t -> string
+
+  (* This is the OCaml type associated with a nonterminal
+     symbol. It is known only if a %type declaration was provided.
+     This function is not applicable to the internally generated
+     nonterminals. *)
+
+  val ocamltype: t -> Stretch.ocamltype option
+
+  (* A start symbol always has a type. This allows us to define
+     a simplified version of [ocamltype] for start symbols. *)
+
+  val ocamltype_of_start_symbol: t -> Stretch.ocamltype
+
+  (* Creation of a table indexed by nonterminals. *)
+
+  val init: (t -> 'a) -> 'a array
+
+  (* Iteration over nonterminals. The order in which elements are
+     examined, and the order of [map]'s output list, correspond to the
+     numeric indices produced by [n2i] above. *)
+
+  val iter: (t -> unit) -> unit
+  val fold: (t -> 'a -> 'a) -> 'a -> 'a
+  val map: (t -> 'a) -> 'a list
+
+  (* Iteration over all nonterminals, except the start nonterminals. *)
+
+  val iterx: (t -> unit) -> unit
+  val foldx: (t -> 'a -> 'a) -> 'a -> 'a
+
+  (* Tabulation of a function over nonterminals. *)
+
+  val tabulate: (t -> 'a) -> (t -> 'a)
+
+  (* [positions nt] is a list of the positions associated with the
+     definition of [nt]. There can be more than one position because
+     definitions can be split over multiple files. *)
+
+  val positions: t -> Positions.t list
+
+  (* This tells whether a non-terminal symbol is one of the start
+     symbols. *)
+
+  val is_start: t -> bool
+
+  (* [attributes nt] is the list of attributes attached with the nonterminal
+     symbol [nt]. *)
+
+  val attributes: t -> Syntax.attribute list
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Sets of nonterminals. *)
+
+module NonterminalMap : GMap.S with type key = Nonterminal.t
+
+module NonterminalSet = NonterminalMap.Domain
+
+(* ------------------------------------------------------------------------ *)
+(* Terminals. *)
+
+module Terminal : sig
+
+  (* The type of terminals. *)
+
+  type t
+
+  (* The number of terminals. This includes the two pseudo-tokens
+     [#] and [error]. *)
+
+  val n: int
+
+  (* Comparison. *)
+
+  val equal: t -> t -> bool
+  val compare: t -> t -> int
+
+  (* [lookup] maps an identifier to a terminal, or raises [Not_found]. *)
+
+  val lookup : string -> t
+
+  (* Terminals can be converted to integers. This feature is exploited in the
+     table-based back-end and in [LRijkstra]. The reverse conversion, [i2t],
+     is unsafe and should not be used. [LRijkstra] uses it :-) *)
+
+  val t2i: t -> int
+  val i2t: int -> t (* unsafe! *)
+
+  (* This produces a string representation of a terminal. *)
+
+  val print: t -> string
+
+  (* This is the OCaml type associated with a terminal
+     symbol. It is known only if the %token declaration was
+     accompanied with a type. *)
+
+  val ocamltype: t -> Stretch.ocamltype option
+
+  (* These are the two pseudo-tokens [#] and [error]. The former is
+     used to denote the end of the token stream. The latter is
+     accessible to the user and is used for handling errors. *)
+
+  val sharp: t
+  val error: t
+
+  (* This is the programmer-defined [EOF] token, if there is one. It
+     is recognized based solely on its name, which is fragile, but
+     this behavior is documented. This token is assumed to represent
+     [ocamllex]'s [eof] pattern. It is used only by the reference
+     interpreter, and in a rather non-essential way. *)
+
+  val eof: t option
+
+  (* A terminal symbol is pseudo if it is [#] or [error]. It is real otherwise. *)
+
+  val pseudo: t -> bool
+  val real: t -> bool
+
+  (* Creation of a table indexed by terminals. *)
+
+  val init: (t -> 'a) -> 'a array
+
+  (* Iteration over terminals. The order in which elements are
+     examined, and the order of [map]'s output list, correspond to the
+     numeric indices produced by [t2i] above. *)
+
+  val iter: (t -> unit) -> unit
+  val fold: (t -> 'a -> 'a) -> 'a -> 'a
+  val map: (t -> 'a) -> 'a list
+
+  (* Iteration over all terminals except [#]. *)
+
+  val foldx: (t -> 'a -> 'a) -> 'a -> 'a
+  val mapx: (t -> 'a) -> 'a list
+
+  (* [iter_real] offers iteration over all real terminals. *)
+
+  val iter_real: (t -> unit) -> unit
+
+  (* [attributes t] is the list of attributes attached with the terminal
+     symbol [t]. *)
+
+  val attributes: t -> Syntax.attribute list
+
+  (* The sub-module [Word] offers an implementation of words (that is,
+     sequences) of terminal symbols. It is used by [LRijkstra]. We
+     make it a functor, because it has internal state (a hash table)
+     and a side effect (failure if there are more than 256 terminal
+     symbols). *)
+
+  (* The type [word] should be treated, as much as possible, as an
+     abstract type. In fact, for efficiency reasons, we represent a
+     word as a unique integer codes, and we allocate these integer
+     codes sequentially, from 0 upwards. The conversion from [int]
+     to [word] is of course unsafe and should be used wisely. *)
+
+  module Word (X : sig end) : sig
+
+    type word = int
+    val epsilon: word
+    val singleton: t -> word
+    val append: word -> word -> word
+    val length: word -> int
+    (* [first w z] returns the first symbol of the word [w.z]. *)
+    val first: word -> t -> t
+    val elements: word -> t list
+    val print: word -> string
+    (* [verbose()] prints statistics about the use of the internal
+       hash-consing table so far. *)
+    val verbose: unit -> unit
+    (* Lexicographic ordering. *)
+    val compare: word -> word -> int
+  end
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Sets and maps over terminals. *)
+
+module TerminalSet : sig
+
+  (* All of the operations documented in [GSet] are available. *)
+
+  include GSet.S with type element = Terminal.t
+
+  (* This offers a string representation of a set of terminals. The
+     symbols are simply listed one after the other and separated with
+     spaces. *)
+
+  val print: t -> string
+
+  (* This is the set of all terminal symbols except the pseudo-tokens
+     [#] and [error]. *)
+
+  val universe: t
+
+end
+
+(* All of the operations documented in [GMap] are available. *)
+
+module TerminalMap : GMap.S with type key = Terminal.t
+
+(* ------------------------------------------------------------------------ *)
+(* Symbols. *)
+
+module Symbol : sig
+
+  (* A symbol is either a nonterminal or a terminal. *)
+
+  type t =
+    | N of Nonterminal.t
+    | T of Terminal.t
+
+  (* [lookup] maps an identifier to a symbol, or raises [Not_found]. *)
+
+  val lookup : string -> t
+
+  (* Comparison. *)
+
+  val equal: t -> t -> bool
+  val lequal: t list -> t list -> bool
+
+  (* These produce a string representation of a symbol, of a list of
+     symbols, or of an array of symbols. The symbols are simply listed
+     one after the other and separated with spaces. [printao] prints
+     an array of symbols, starting at a particular offset. [printaod]
+     is analogous, but can also print a single dot at a particular
+     position between two symbols. *)
+
+  val print: t -> string
+  val printl: t list -> string
+  val printa: t array -> string
+  val printao: int -> t array -> string
+  val printaod: int -> int -> t array -> string
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Sets and maps over symbols. *)
+
+(* All of the operations documented in [Set] are available. *)
+
+module SymbolSet : Set.S with type elt = Symbol.t
+
+module SymbolMap : sig
+
+  (* All of the operations documented in [Map] are available. *)
+
+  include Map.S with type key = Symbol.t
+
+  val domain: 'a t -> key list
+
+  (* This returns [true] if and only if all of the symbols in
+     the domain of the map at hand are nonterminals. *)
+
+  val purelynonterminal: 'a t -> bool
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Productions. *)
+
+module Production : sig
+
+  (* This is the type of productions. This includes user-defined
+     productions as well as the internally generated productions
+     associated with the start symbols. *)
+
+  type index
+
+  (* Comparison. *)
+
+  val compare: index -> index -> int
+
+  (* Productions can be converted to integers and back. This is unsafe
+     and should be avoided as much as possible. This feature is
+     exploited, for efficiency, in the encoding of items. *)
+
+  val p2i: index -> int
+  val i2p: int -> index
+
+  (* The number of productions. *)
+
+  val n: int
+
+  (* These map a production index to the production's definition, that
+     is, a nonterminal (the left-hand side) and an array of symbols
+     (the right-hand side). *)
+
+  val def: index -> Nonterminal.t * Symbol.t array
+  val nt: index -> Nonterminal.t
+  val rhs: index -> Symbol.t array
+  val length: index -> int
+
+  (* This maps a production index to an array of the identifiers that
+     should be used for naming the semantic values of the symbols in
+     the right-hand side. *)
+
+  val identifiers: index -> Syntax.identifier array
+
+  (* This maps a production index to the production's semantic action.
+     This function is not applicable to a start production. *)
+
+  val action: index -> Syntax.action
+
+  (* [positions prod] is a list of the positions associated with
+     production [prod]. This is usually a singleton list, but there
+     can be more than one position for start productions when the
+     definition of the corresponding start symbol is split over
+     multiple files. *)
+
+  val positions: index -> Positions.t list
+
+  (* [lhs_attributes prod] returns the attributes attached with the
+     head symbol of the production [prod]. It is equivalent to
+     [Nonterminal.attributes (nt prod)]. [rhs_attributes prod] returns
+     an array of the attributes attached with each element in the
+     right-hand side of the production [prod]. *)
+
+  val lhs_attributes: index -> Syntax.attributes
+  val rhs_attributes: index -> Syntax.attributes array
+
+  (* Creation of a table indexed by productions. *)
+
+  val init: (index -> 'a) -> 'a array
+
+  (* Iteration over all productions. The order in which elements
+     are examined, and the order of [map]'s output list, correspond
+     to the numeric indices produced by [p2i] above. *)
+
+  val iter: (index -> unit) -> unit
+  val fold: (index -> 'a -> 'a) -> 'a -> 'a
+  val map: (index -> 'a) -> 'a list
+  val amap: (index -> 'a) -> 'a array
+
+  (* Iteration over all productions, except the start productions. *)
+
+  val iterx: (index -> unit) -> unit
+  val foldx: (index -> 'a -> 'a) -> 'a -> 'a
+  val mapx: (index -> 'a) -> 'a list
+
+  (* This maps a (user) non-terminal start symbol to the corresponding
+     start production. *)
+
+  val startsymbol2startprod: Nonterminal.t -> index
+
+  (* Iteration over the productions associated with a specific
+     nonterminal. *)
+
+  val iternt: Nonterminal.t -> (index -> unit) -> unit
+  val foldnt: Nonterminal.t -> 'a -> (index -> 'a -> 'a) -> 'a
+
+  (* This allows determining whether a production is a start
+     production. If it is a start production, the start symbol that it
+     is associated with is returned. If it is a regular production,
+     nothing is returned. *)
+
+  val classify: index -> Nonterminal.t option
+
+  (* [is_start] is easier to use than [classify] when the start symbol
+     is not needed. *)
+
+  val is_start: index -> bool
+
+  (* The integer [start] is published so as to allow the table back-end
+     to produce code for [is_start]. It should not be used otherwise. *)
+
+  val start: int
+
+  (* This produces a string representation of a production. It should
+     never be applied to a start production, as we do not wish users
+     to become aware of the existence of these extra productions. *)
+
+  val print: index -> string
+
+  (* Tabulation of a Boolean function over productions. [tabulateb f]
+     returns a tabulated version of [f] as well as the number of
+     productions where [f] is true. *)
+
+  val tabulate: (index -> 'a) -> (index -> 'a)
+  val tabulateb: (index -> bool) -> (index -> bool) * int
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Maps over productions. *)
+
+module ProductionMap : sig
+
+  include GMap.S with type key = Production.index
+
+  (* Iteration over the start productions only. *)
+
+  val start: (Production.index -> 'a) -> 'a t
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Analysis of the grammar. *)
+
+module Analysis : sig
+
+  (* [nullable nt] is the NULLABLE flag of the non-terminal symbol [nt].
+     That is, it is true if and only if this symbol produces the empty
+     word [epsilon]. *)
+
+  val nullable: Nonterminal.t -> bool
+  val nullable_symbol: Symbol.t -> bool
+
+  (* [first nt] is the FIRST set of the non-terminal symbol [nt]. *)
+
+  val first: Nonterminal.t -> TerminalSet.t
+  val first_symbol: Symbol.t -> TerminalSet.t
+
+  (* [nullable_first_prod prod i] considers the suffix of the production
+     [prod] defined by offset [i]. It returns its NULLABLE flag as well
+     as its FIRST set. The offset [i] must be contained between [0] and
+     [n], inclusive, where [n] is the length of production [prod]. *)
+
+  val nullable_first_prod: Production.index -> int -> bool * TerminalSet.t
+
+  (* [first_prod_lookahead prod i t] computes [FIRST(alpha.t)], where [alpha]
+     is the suffix of the production defined by offset [i], and [t] is a
+     terminal symbol. The offset [i] must be contained between [0] and [n],
+     inclusive, where [n] is the length of production [prod]. *)
+
+  val first_prod_lookahead: Production.index -> int -> Terminal.t -> TerminalSet.t
+
+  (* [explain_first_rhs tok rhs i] explains why the token [tok] appears
+     in the FIRST set for the string of symbols found at offset [i] in
+     the array [rhs]. *)
+
+  val explain_first_rhs: Terminal.t -> Symbol.t array -> int -> string
+
+  (* [follow nt] is the FOLLOW set of the non-terminal symbol [nt], that
+     is, the set of terminal symbols that could follow an expansion of
+     [nt] in a valid sentence. *)
+
+  val follow: Nonterminal.t -> TerminalSet.t
+
+  (* [attributes] are the attributes attached with the grammar. *)
+
+  val attributes: Syntax.attributes
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Conflict resolution via precedences. *)
+
+module Precedence : sig
+
+  (* Shift/reduce conflicts require making a choice between shifting a
+     token and reducing a production. How these choices are made is of
+     no concern to the back-end, but here is a rough explanation.
+
+     Shifting is preferred when the token has higher precedence than
+     the production, or they have same precedence and the token is
+     right-associative.
+
+     Reducing is preferred when the token has lower precedence than
+     the production, or they have same precedence and the token is
+     left-associative.
+
+     Neither is allowed when the token and the production have same
+     precedence and the token is non-associative.
+
+     No preference is explicitly specified when the token or the
+     production has undefined precedence. In that case, the default
+     choice is to prefer shifting, but a conflict will be reported. *)
+
+  type choice =
+    | ChooseShift
+    | ChooseReduce
+    | ChooseNeither
+    | DontKnow
+
+  val shift_reduce: Terminal.t -> Production.index -> choice
+
+  (* Reduce/reduce conflicts require making a choice between reducing
+     two distinct productions. This is done by exploiting a partial
+     order on productions.
+
+     For compatibility with ocamlyacc, this order should be total and
+     should correspond to textual order when the two productions
+     originate in the same source file. When they originate in
+     different source files, the two productions should be
+     incomparable. *)
+
+  val reduce_reduce: Production.index -> Production.index -> Production.index option
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* [%on_error_reduce] declarations. *)
+
+module OnErrorReduce : sig
+
+  (* [reduce prod] tells whether the left-hand side of [prod] (a nonterminal
+     symbol) appears in an [%on_error_reduce] declaration. *)
+
+  val reduce: Production.index -> bool
+
+  (* [iter f] applies the function [f] in turn, in an arbitrary order, to
+     every nonterminal symbol that appears in an [%on_error_reduce]
+     declaration. *)
+
+  val iter: (Nonterminal.t -> unit) -> unit
+
+  (* When two productions could be reduced, in a single state, due to
+     [%on_error_reduce] declarations, these productions can be compared, using
+     [preferable], to test if one of them takes precedence over the other.
+     This is a partial order; two productions may be incomparable. *)
+
+  val preferable: Production.index -> Production.index -> bool
+
+end
+
+(* ------------------------------------------------------------------------ *)
+(* Diagnostics. *)
+
+(* This function prints warnings about useless precedence declarations for
+   terminal symbols (%left, %right, %nonassoc) and productions (%prec). It
+   should be invoked after only the automaton has been constructed. *)
+
+val diagnostics: unit -> unit
+
+(* ------------------------------------------------------------------------ *)
+
+end (* module Make *)
diff -Naur menhir-20171013/src/IncrementalEngine.ml menhir-20171013-b/src/IncrementalEngine.ml
--- menhir-20171013/src/IncrementalEngine.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/IncrementalEngine.ml	2018-08-31 14:45:36.174860715 +0200
@@ -210,8 +210,13 @@
      for some type ['a], the state [s] has type ['a lr1state] and the value [v]
      has type ['a]. In other words, the type [element] is an existential type. *)
 
-  type element =
-    | Element: 'a lr1state * 'a * position * position -> element
+  type 'b element_picker = {
+      pick_element : 'a . 'a lr1state * 'a * position * position -> 'b
+    }
+
+  type element = {
+      element : 'b . 'b element_picker -> 'b
+    }
 
   (* The parser's stack is (or, more precisely, can be viewed as) a stream of
      elements. The type [stream] is defined by the module [General]. *)
@@ -339,15 +344,20 @@
      the disjoint union of the types ['a terminal] and ['a nonterminal]. *)
 
   type 'a symbol =
-    | T : 'a terminal -> 'a symbol
-    | N : 'a nonterminal -> 'a symbol
+    | T of 'a terminal
+    | N of 'a nonterminal
 
   (* The type [xsymbol] is an existentially quantified version of the type
      ['a symbol]. This type is useful in situations where the index ['a]
      is not statically known. *)
 
-  type xsymbol =
-    | X : 'a symbol -> xsymbol
+  type 'b xsymbol_picker = {
+      pick_symbol : 'a . 'a symbol -> 'b
+    }
+
+  type xsymbol = {
+      xsymbol : 'b . 'b xsymbol_picker -> 'b
+    }
 
 end
 
diff -Naur menhir-20171013/src/InspectionTableInterpreter.ml menhir-20171013-b/src/InspectionTableInterpreter.ml
--- menhir-20171013/src/InspectionTableInterpreter.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/InspectionTableInterpreter.ml	2018-08-31 14:45:36.174860715 +0200
@@ -28,11 +28,16 @@
      where these types are defined. *)
 
   type 'a symbol =
-    | T : 'a terminal -> 'a symbol
-    | N : 'a nonterminal -> 'a symbol
+    | T of 'a terminal
+    | N of 'a nonterminal
 
-  type xsymbol =
-    | X : 'a symbol -> xsymbol
+  type 'b xsymbol_picker = {
+      pick_symbol : 'a . 'a symbol -> 'b
+    }
+
+  type xsymbol = {
+      xsymbol : 'b . 'b xsymbol_picker -> 'b
+    }
 
 end
 
diff -Naur menhir-20171013/src/interpret.ml menhir-20171013-b/src/interpret.ml
--- menhir-20171013/src/interpret.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/interpret.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 module I = Invariant (* artificial dependency *)
 module D = Default   (* artificial dependency *)
 
@@ -508,12 +510,15 @@
          loop (Comment comments :: accu) segments
     | (Segment, _, lexbuf) :: segments ->
         (* Read a series of located sentences. *)
-        match SentenceParser.entry SentenceLexer.lex lexbuf with
-        | exception Parsing.Parse_error ->
+        match
+          try Some (SentenceParser.entry SentenceLexer.lex lexbuf)
+          with Parsing.Parse_error -> None
+        with
+        | None ->
             Error.error
               [Positions.cpos lexbuf]
               "ill-formed sentence."
-        | sentences ->
+        | Some sentences ->
             (* In principle, we should now find a segment of whitespace
                followed with a segment of text. By construction, the two
                kinds of segments alternate. *)
@@ -549,14 +554,14 @@
     List.fold_left (fun table (sentences_and_states, message) ->
       List.fold_left (fun table (sentence2, target) ->
         let s = target2state target in
-        match Lr1.NodeMap.find s table with
-        | sentence1, _ ->
+        match Lr1.NodeMap.find_opt s table with
+        | Some (sentence1, _) ->
             if detect_redundancy then
               Error.signal (fst sentence1 @ fst sentence2)
                    "these sentences both cause an error in state %d."
                    (Lr1.number s);
             table
-        | exception Not_found ->
+        | None ->
             Lr1.NodeMap.add s (sentence2, message) table
       ) table sentences_and_states
     ) Lr1.NodeMap.empty runs
diff -Naur menhir-20171013/src/IO.ml menhir-20171013-b/src/IO.ml
--- menhir-20171013/src/IO.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/IO.ml	2018-08-31 14:45:36.174860715 +0200
@@ -13,6 +13,8 @@
 
 (* Input-output utilities. *)
 
+open Stdcompat
+
 (* ------------------------------------------------------------------------- *)
 (* [try/finally] has the same semantics as in Java. *)
 
diff -Naur menhir-20171013/src/keyword.ml menhir-20171013-b/src/keyword.ml
--- menhir-20171013/src/keyword.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/keyword.ml	2018-08-31 14:45:36.178860759 +0200
@@ -15,6 +15,8 @@
    that help deal with the keywords that we recognize within
    semantic actions. *)
 
+open Stdcompat
+
 (* ------------------------------------------------------------------------- *)
 (* Types. *)
 
diff -Naur menhir-20171013/src/keyword.mli menhir-20171013-b/src/keyword.mli
--- menhir-20171013/src/keyword.mli	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/keyword.mli	2018-08-31 14:45:36.178860759 +0200
@@ -61,6 +61,6 @@
 (* Sets of keywords. *)
 
 module KeywordSet : sig
-  include Set.S with type elt = keyword
+  include Stdcompat.Set.S with type elt = keyword
   val map: (keyword -> keyword) -> t -> t
 end
diff -Naur menhir-20171013/src/lexer.mll menhir-20171013-b/src/lexer.mll
--- menhir-20171013/src/lexer.mll	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/lexer.mll	2018-08-31 14:45:36.178860759 +0200
@@ -13,6 +13,8 @@
 
 {
 
+open Stdcompat
+
 open Lexing
 open Parser
 open Positions
diff -Naur menhir-20171013/src/lr1.ml menhir-20171013-b/src/lr1.ml
--- menhir-20171013/src/lr1.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/lr1.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 open Grammar
 module S = Slr (* artificial dependency; ensures that [Slr] runs first *)
 
diff -Naur menhir-20171013/src/lr1.mli menhir-20171013-b/src/lr1.mli
--- menhir-20171013/src/lr1.mli	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/lr1.mli	2018-08-31 14:45:36.178860759 +0200
@@ -36,7 +36,7 @@
 
 module NodeSet : Set.S with type elt = node
 
-module NodeMap : Map.S with type key = node
+module NodeMap : Stdcompat.Map.S with type key = node
 
 (* These are the automaton's entry states, indexed by the start productions. *)
 
diff -Naur menhir-20171013/src/LRijkstra.ml menhir-20171013-b/src/LRijkstra.ml
--- menhir-20171013/src/LRijkstra.ml	2018-08-31 14:44:19.958046470 +0200
+++ menhir-20171013-b/src/LRijkstra.ml	2018-08-31 14:45:36.174860715 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 (* The purpose of this algorithm is to find, for each pair of a state [s]
    and a terminal symbol [z] such that looking at [z] in state [s] causes
    an error, a minimal path (starting in some initial state) that actually
@@ -243,10 +245,10 @@
       grammar_uses_error := true;
       false
   | a :: w ->
-      match SymbolMap.find a (Lr1.transitions s) with
-      | s ->
+      match SymbolMap.find_opt a (Lr1.transitions s) with
+      | Some s ->
           reduction_path_exists s w prod
-      | exception Not_found ->
+      | None ->
           false
 
 (* ------------------------------------------------------------------------ *)
@@ -369,10 +371,10 @@
         assert (can_reduce t.current prod);
         t.productions <- prod :: t.productions
     | a :: w ->
-        match SymbolMap.find a (Lr1.transitions t.current) with
-        | exception Not_found ->
+        match SymbolMap.find_opt a (Lr1.transitions t.current) with
+        | None ->
             assert false
-        | successor ->
+        | Some successor ->
             (* Find our child at [a], or create it. *)
             let t' =
               try
@@ -911,9 +913,9 @@
       foreach (fun z ->
         assert (Terminal.real z);
         let key = pack nt a z in
-        match H.find m key with
-        | w -> f w z
-        | exception Not_found -> ()
+        match H.find_opt m key with
+        | Some w -> f w z
+        | None -> ()
       )
 
   let size () =
@@ -944,8 +946,8 @@
     F.query s (W.first w z) (fun fact ->
       assert (compatible (lookahead fact) (W.first w z));
       (* ... try to take one step in the trie along an edge labeled [nt]. *)
-      match Trie.step sym (position fact) with
-      | position ->
+      match try Some (Trie.step sym (position fact)) with Not_found -> None with
+      | Some position ->
           (* This takes us to a new state whose incoming symbol is [nt].
              Hence, this state is not solid. In order to satisfy invariant 2,
              we must create fact whose lookahead assumption is not [any].
@@ -956,7 +958,7 @@
           if not (causes_an_error (Trie.current position) z) then
             let word = W.append (word fact) w in
             enqueue position word z
-      | exception Not_found ->
+      | None ->
           (* Could not take a step in the trie. This means this branch
              leads nowhere of interest, and was pruned when the trie
              was constructed. *)
@@ -998,15 +1000,15 @@
   Lr1.transitions current |> SymbolMap.iter (fun sym target ->
     (* ... try to follow this transition in the trie [position],
        down to a child which we call [child]. *)
-    match Trie.step sym position, sym with
+    match try Some (Trie.step sym position, sym) with Not_found -> None with
 
-    | exception Not_found ->
+    | None ->
 
         (* Could not take a step in the trie. This means this transition
            leads nowhere of interest. *)
         ()
 
-    | child, Symbol.T t ->
+    | Some (child, Symbol.T t) ->
 
         (* 1a. The transition exists in the trie, and [sym] is in fact a
            terminal symbol [t]. We note that [t] cannot be the [error] token,
@@ -1029,7 +1031,7 @@
           let word = W.append word (W.singleton t) in
           enqueue child word any
 
-    | child, Symbol.N nt ->
+    | Some (child, Symbol.N nt) ->
 
         (* 1b. The transition exists in the trie, and [sym] is in fact a
            nonterminal symbol [nt]. *)
diff -Naur menhir-20171013/src/misc.ml menhir-20171013-b/src/misc.ml
--- menhir-20171013/src/misc.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/misc.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 let ( $$ ) x f = f x
 
 let unSome = function
diff -Naur menhir-20171013/src/nonTerminalDefinitionInlining.ml menhir-20171013-b/src/nonTerminalDefinitionInlining.ml
--- menhir-20171013/src/nonTerminalDefinitionInlining.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/nonTerminalDefinitionInlining.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 open Keyword
 open UnparameterizedSyntax
 open ListMonad
diff -Naur menhir-20171013/src/PackedIntArray.ml menhir-20171013-b/src/PackedIntArray.ml
--- menhir-20171013/src/PackedIntArray.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/PackedIntArray.ml	2018-08-31 14:45:36.174860715 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 (* A packed integer array is represented as a pair of an integer [k] and
    a string [s]. The integer [k] is the number of bits per integer that we
    use. The string [s] is just an array of bits, which is read in 8-bit
diff -Naur menhir-20171013/src/parameterizedGrammar.ml menhir-20171013-b/src/parameterizedGrammar.ml
--- menhir-20171013/src/parameterizedGrammar.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/parameterizedGrammar.ml	2018-08-31 14:45:36.178860759 +0200
@@ -683,11 +683,11 @@
   (* Instantiate the branches of sym for a particular set of actual
      parameters. *)
   and expand_branches subst sym actual_parameters : symbol =
-    match StringMap.find (Positions.value sym) p_grammar.p_rules with
-    | exception Not_found ->
+    match StringMap.find_opt (Positions.value sym) p_grammar.p_rules with
+    | None ->
         (* [sym] is a terminal symbol. Expansion is not needed. *)
         Positions.value sym
-    | prule ->
+    | Some prule ->
         let nsym = name_of sym actual_parameters in
         (* Check up front if [nsym] is marked, so as to deal with it just once. *)
         if Hashtbl.mem expanded_rules nsym then
diff -Naur menhir-20171013/src/parserAux.ml menhir-20171013-b/src/parserAux.ml
--- menhir-20171013/src/parserAux.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/parserAux.ml	2018-08-31 14:49:08.960484509 +0200
@@ -11,6 +11,10 @@
 (*                                                                            *)
 (******************************************************************************)
 
+module MenhirOption = Option
+
+open Stdcompat
+
 open Positions
 open Syntax
 
@@ -56,7 +60,7 @@
 end)
 
 let defined_identifiers (_, ido, _, _) accu =
-  Option.fold IdSet.add ido accu
+  MenhirOption.fold IdSet.add ido accu
 
 let defined_identifiers (producers : early_producers) =
   List.fold_right defined_identifiers producers IdSet.empty
diff -Naur menhir-20171013/src/parserAux.ml~ menhir-20171013-b/src/parserAux.ml~
--- menhir-20171013/src/parserAux.ml~	1970-01-01 01:00:00.000000000 +0100
+++ menhir-20171013-b/src/parserAux.ml~	2018-08-31 14:45:36.178860759 +0200
@@ -0,0 +1,121 @@
+(******************************************************************************)
+(*                                                                            *)
+(*                                   Menhir                                   *)
+(*                                                                            *)
+(*                       François Pottier, Inria Paris                        *)
+(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
+(*                                                                            *)
+(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
+(*  terms of the GNU General Public License version 2, as described in the    *)
+(*  file LICENSE.                                                             *)
+(*                                                                            *)
+(******************************************************************************)
+
+open Stdcompat
+
+open Positions
+open Syntax
+
+type early_producer =
+  Positions.t *
+  identifier located option *
+  parameter *
+  attributes
+
+type early_producers =
+  early_producer list
+
+type early_production =
+  early_producers *
+  string located option * (* optional precedence *)
+  branch_production_level *
+  Positions.t
+
+type early_productions =
+  early_production list
+
+let new_precedence_level =
+  let c = ref 0 in
+  fun pos1 pos2 ->
+    incr c;
+    PrecedenceLevel (InputFile.get_input_file (), !c, pos1, pos2)
+
+let new_production_level =
+  let c = ref 0 in
+  fun () ->
+    incr c;
+    ProductionLevel (InputFile.get_input_file (), !c)
+
+let new_on_error_reduce_level =
+  new_production_level
+    (* the counter is shared with [new_production_level],
+       but this is irrelevant *)
+
+module IdSet = Set.Make (struct
+  type t = identifier located
+  let compare id1 id2 =
+    compare (value id1) (value id2)
+end)
+
+let defined_identifiers (_, ido, _, _) accu =
+  Option.fold IdSet.add ido accu
+
+let defined_identifiers (producers : early_producers) =
+  List.fold_right defined_identifiers producers IdSet.empty
+
+let check_production_group (right_hand_sides : early_productions) =
+  match right_hand_sides with
+  | [] ->
+      (* A production group cannot be empty. *)
+      assert false
+  | (producers, _, _, _) :: right_hand_sides ->
+      let ids = defined_identifiers producers in
+      List.iter (fun (producers, _, _, _) ->
+        let ids' = defined_identifiers producers in
+        try
+          let id =
+            IdSet.choose (IdSet.union
+                                (IdSet.diff ids ids')
+                                (IdSet.diff ids' ids))
+          in
+          Error.error [Positions.position id]
+            "two productions that share a semantic action must define exactly\n\
+             the same identifiers. Here, \"%s\" is defined\n\
+             in one production, but not in all of them."
+            (Positions.value id)
+        with Not_found ->
+          ()
+      ) right_hand_sides
+
+(* [normalize_producer i p] assigns a name of the form [_i]
+   to the unnamed producer [p]. *)
+let normalize_producer i (pos, opt_identifier, parameter, attrs) =
+  let id =
+    match opt_identifier with
+      | Some id -> id
+      | None -> Positions.with_pos pos ("_" ^ string_of_int (i + 1))
+  in
+  (id, parameter, attrs)
+
+let normalize_producers (producers : early_producers) : producer list =
+  List.mapi normalize_producer producers
+
+let override pos o1 o2 =
+  match o1, o2 with
+  | Some _, Some _ ->
+      Error.signal [ pos ] "this production carries two %%prec declarations.";
+      o2
+  | None, Some _ ->
+      o2
+  | _, None ->
+      o1
+
+(* Only unnamed producers can be referred to using positional identifiers.
+   Besides, such positions must be taken in the interval [1
+   .. List.length producers]. The output array [p] is such that
+   [p.(idx) = Some x] if [idx] must be referred to using [x], not
+   [$(idx + 1)]. *)
+let producer_names (producers : early_producers) =
+  producers
+  |> List.map (fun (_, oid, _, _) -> Option.map Positions.value oid)
+  |> Array.of_list
diff -Naur menhir-20171013/src/partialGrammar.ml menhir-20171013-b/src/partialGrammar.ml
--- menhir-20171013/src/partialGrammar.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/partialGrammar.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 open Misc
 open Syntax
 open Positions
@@ -315,26 +317,28 @@
   Hashtbl.create 13
 
 let store_symbol (symbols : symbol_table) symbol kind =
-  match find_symbol symbols symbol, kind with
+  match try Some (find_symbol symbols symbol, kind) with Not_found -> None with
 
   (* The symbol is not known so far. Add it. *)
-  | exception Not_found ->
+  | None ->
       add_in_symbol_table symbols symbol kind
 
   (* There are two definitions of this symbol in one grammatical unit
      (that is, one .mly file), and at least one of them is private.
      This is forbidden. *)
-  | PrivateNonTerminal p, PrivateNonTerminal p'
+  | Some (
+    PrivateNonTerminal p, PrivateNonTerminal p'
   | PublicNonTerminal p, PrivateNonTerminal p'
-  | PrivateNonTerminal p, PublicNonTerminal p' ->
+  | PrivateNonTerminal p, PublicNonTerminal p') ->
       Error.error [ p; p']
         "the nonterminal symbol %s is multiply defined.\n\
          Only %%public symbols can have split definitions."
         symbol
 
   (* The symbol is known to be a token but declared as a nonterminal.*)
-  | Token tkp, (PrivateNonTerminal p | PublicNonTerminal p)
-  | (PrivateNonTerminal p | PublicNonTerminal p), Token tkp ->
+  | Some (
+    Token tkp, (PrivateNonTerminal p | PublicNonTerminal p)
+  | (PrivateNonTerminal p | PublicNonTerminal p), Token tkp) ->
       Error.error [ p; tkp.tk_position ]
            "the identifier %s is a reference to a token."
            symbol
@@ -343,13 +347,14 @@
      As of 2017/03/29, splitting the definition of a %public nonterminal
      symbol is permitted. (It used to be permitted over multiple units,
      but forbidden within a single unit.) *)
-  | _, DontKnow _
+  | Some (
+    _, DontKnow _
   | Token _, Token _
-  | PublicNonTerminal _, PublicNonTerminal _ ->
+  | PublicNonTerminal _, PublicNonTerminal _) ->
       symbols
 
   (* We learn that the symbol is a nonterminal or a token. *)
-  | DontKnow _, _ ->
+  | Some (DontKnow _, _) ->
       replace_in_symbol_table symbols symbol kind
 
 let store_used_symbol position tokens symbols symbol =
diff -Naur menhir-20171013/src/pprint.ml menhir-20171013-b/src/pprint.ml
--- menhir-20171013/src/pprint.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/pprint.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 (* This is an adaptation of Daan Leijen's [PPrint] library, which itself is
    based on the ideas developed by Philip Wadler in ``A Prettier Printer''.
    For more information, see:
diff -Naur menhir-20171013/src/printer.ml menhir-20171013-b/src/printer.ml
--- menhir-20171013/src/printer.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/printer.ml	2018-08-31 14:45:36.178860759 +0200
@@ -13,6 +13,8 @@
 
 (* A pretty-printer for [IL]. *)
 
+open Stdcompat
+
 open IL
 
 module PreliminaryMake (X : sig
diff -Naur menhir-20171013/src/referenceInterpreter.ml menhir-20171013-b/src/referenceInterpreter.ml
--- menhir-20171013/src/referenceInterpreter.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/referenceInterpreter.ml	2018-08-31 14:45:36.178860759 +0200
@@ -316,8 +316,8 @@
     match E.top env with
     | None ->
         entry
-    | Some (E.Element (s, _, _, _)) ->
-        s
+    | Some element ->
+        element.E.element { E.pick_element = fun (s, _, _, _) -> (s : E.state) }
   in
 
   (* Set up a function that delivers tokens one by one. *)
diff -Naur menhir-20171013/src/stringMap.ml menhir-20171013-b/src/stringMap.ml
--- menhir-20171013/src/stringMap.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/stringMap.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,7 +11,7 @@
 (*                                                                            *)
 (******************************************************************************)
 
-include Map.Make (String)
+include Stdcompat.Map.Make (String)
 
 let cardinal s =
   fold (fun _ _ x -> x + 1) s 0
diff -Naur menhir-20171013/src/stringMap.mli menhir-20171013-b/src/stringMap.mli
--- menhir-20171013/src/stringMap.mli	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/stringMap.mli	2018-08-31 14:45:36.178860759 +0200
@@ -11,7 +11,7 @@
 (*                                                                            *)
 (******************************************************************************)
 
-include Map.S with type key = string
+include Stdcompat.Map.S with type key = string
 
 val cardinal : 'a t -> int
 
diff -Naur menhir-20171013/src/unparameterizedPrinter.ml menhir-20171013-b/src/unparameterizedPrinter.ml
--- menhir-20171013/src/unparameterizedPrinter.ml	2018-08-31 14:44:19.962046513 +0200
+++ menhir-20171013-b/src/unparameterizedPrinter.ml	2018-08-31 14:45:36.178860759 +0200
@@ -11,6 +11,8 @@
 (*                                                                            *)
 (******************************************************************************)
 
+open Stdcompat
+
 open Printf
 open Positions
 open Syntax

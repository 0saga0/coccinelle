\documentclass{article}
\usepackage{fullpage}

\newcommand{\U}{\,\mbox{\sf{U}}\,}
\newcommand{\A}{\mbox{\sf{A}}}
\newcommand{\E}{\mbox{\sf{A}}}
\newcommand{\AX}{\mbox{\sf{AX}}}
\newcommand{\EX}{\mbox{\sf{EX}}}
\newcommand{\AF}{\mbox{\sf{AF}}}
\newcommand{\EF}{\mbox{\sf{EF}}}
\newcommand{\AG}{\mbox{\sf{AG}}}
\newcommand{\EG}{\mbox{\sf{EG}}}

\newcommand{\mita}[1]{\mbox{\it{{#1}}}}
\newcommand{\mtt}[1]{\mbox{\tt{{#1}}}}
\newcommand{\msf}[1]{\mbox{\sf{{#1}}}}
\newcommand{\mrm}[1]{\mbox{\rm{{#1}}}}
\newcommand{\mth}[1]{\({#1}\)}

\newcommand{\ttlb}{\mbox{\tt \char'173}}
\newcommand{\ttrb}{\mbox{\tt \char'175}}

\begin{document}

\begin{quote}\begin{verbatim}

@@
@@

f(X);
...
g(X);
h(X);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v2} . \exists \mita{X} . (\msf{State}(v2) \wedge \mita{f(X);} \wedge (\AX\AF(\exists \mita{v1} . (\msf{State}(v1)\\ \wedge \mita{g(X);} \wedge (\AX(\exists \mita{v0} . (\msf{State}(v0) \wedge \mita{h(X);})))))))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

f(X);
...
g(Y);
h(Z);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v2} . (\msf{State}(v2) \wedge (\exists \mita{X} . \mita{f(X);}) \wedge (\AX\AF(\exists \mita{v1} . (\msf{State}(v1)\\ \wedge (\exists \mita{Y} . \mita{g(Y);}) \wedge (\AX(\exists \mita{v0} . (\msf{State}(v0) \wedge (\exists \mita{Z} . \mita{h(Z);}))))))))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

f(X);
...   WHEN != h(Z)
g(Y);
h(Z);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v3} . (\msf{State}(v3) \wedge (\exists \mita{X} . \mita{f(X);}) \wedge (\AX(\exists \mita{Z} . \A[\neg (\exists \mita{v2} . (\msf{State}(v2)\\ \wedge \mita{h(Z)})) \U \exists \mita{v1} . (\msf{State}(v1) \wedge (\exists \mita{Y} . \mita{g(Y);}) \wedge (\AX(\exists \mita{v0}\\ . (\msf{State}(v0) \wedge \mita{h(Z);}))))]
)))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

f(X);
...   WHEN != h(Q)
g(Y);
h(Z);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v3} . (\msf{State}(v3) \wedge (\exists \mita{X} . \mita{f(X);}) \wedge (\AX\A[\neg (\exists \mita{v2} . (\msf{State}(v2)\\ \wedge (\exists \mita{Q} . \mita{h(Q)}))) \U \exists \mita{v1} . (\msf{State}(v1) \wedge (\exists \mita{Y} . \mita{g(Y);}) \wedge (\AX(\exists \mita{v0}\\ . (\msf{State}(v0) \wedge (\exists \mita{Z} . \mita{h(Z);})))))]
))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

if (X) {
  ...
}
else {
  g(X);
}
h(Z);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v8} . \exists \mita{X} . (\msf{State}(v8) \wedge \mita{if (X) } \wedge (\AX((\msf{TrueBranch} \rightarrow (\exists \mita{v3}\\ . \exists \mita{v1} . (\msf{State}(v3) \wedge \mita{{\ttlb}
  } \wedge \msf{Paren}(v1) \wedge (\AX\AF(\exists \mita{v2} . (\msf{State}(v2)\\ \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v1))))))) \wedge (\msf{FalseBranch} \rightarrow (\exists \mita{v7} . \exists \mita{v4} . (\msf{State}(v7)\\ \wedge \mita{{\ttlb}
  } \wedge \msf{Paren}(v4) \wedge (\AX(\exists \mita{v6} . (\msf{State}(v6) \wedge \mita{g(X);} \wedge (\AX(\exists \mita{v5}\\ . (\msf{State}(v5) \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v4)))))))))) \wedge (\msf{After} \rightarrow (\exists \mita{v0}\\ . (\msf{State}(v0) \wedge (\exists \mita{Z} . \mita{h(Z);})))))))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

<...
  
(
  h(X)
|
  g(Y)
)
...>
\end{verbatim}\end{quote}

\[\begin{array}{l}
\AG((\exists \mita{v0} . (\msf{State}(v0) \wedge (\exists \mita{X} . \exists \mita{Y} . \mita{
(
h(X)
|
g(Y)
)}))) \vee (\neg (\exists \mita{v0}\\ . (\msf{State}(v0) \wedge (\exists \mita{X} . \exists \mita{Y} . \mita{
(
h(X)
|
g(Y)
)})))))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

<...
  
(
  h(X)
|
  g(Y)
)
...>
r(X);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{X} . \A[((\exists \mita{v1} . (\msf{State}(v1) \wedge (\exists \mita{Y} . \mita{
(
h(X)
|
g(Y)
)}))) \vee (\neg (\exists \mita{v1}\\ . (\msf{State}(v1) \wedge (\exists \mita{Y} . \mita{
(
h(X)
|
g(Y)
)}))))) \U \exists \mita{v0} . (\msf{State}(v0)\\ \wedge \mita{r(X);})]

\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@


(
h(X)
|
g(Y)
)
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v0} . (\msf{State}(v0) \wedge (\exists \mita{X} . \exists \mita{Y} . \mita{
(
h(X)
|
g(Y)
)}))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

m(Y);
?h(X);
g(Y);
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v3} . \exists \mita{Y} . (\msf{State}(v3) \wedge \mita{m(Y);} \wedge (\AX((\exists \mita{v1} . (\msf{State}(v1) \wedge (\exists \mita{X}\\ . \mita{h(X);}) \wedge (\AX(\exists \mita{v0} . (\msf{State}(v0) \wedge \mita{g(Y);}))))) \vee ((\neg (\exists \mita{v2} . (\msf{State}(v2)\\ \wedge (\exists \mita{X} . \mita{h(X);})))) \wedge (\exists \mita{v0} . (\msf{State}(v0) \wedge \mita{g(Y);}))))))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

sht/*struct Scsi_Host_Template */.proc_info = proc_info_func;
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v0} . (\msf{State}(v0) \wedge (\exists \mita{sht} . \exists \mita{proc\_info\_func} . \mita{sht/*struct Scsi\_Host\_Template */.proc\_info = proc\_info\_func;}))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

proc_info_func(char *buffer, char **start, off_t offset, int length,
               int hostno, int inout) {
  ...
  struct Scsi_Host *hostptr;
  ...
  hostptr = scsi_host_hn_get(hostno);
  ...
  ?if (hostptr == NULL) ?{
    ?...
  ?}
  ...
  ?scsi_host_put(hostptr);
  ...
}
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v15} . \exists \mita{hostno} . (\msf{State}(v15) \wedge (\exists \mita{buffer} . \exists \mita{start} . \exists \mita{offset}\\ . \exists \mita{length} . \exists \mita{inout} . \mita{proc\_info\_func(char *buffer, char **start, off\_t offset, int length,
               int hostno, int inout) })\\ \wedge (\AX(\exists \mita{v14} . \exists \mita{v0} . (\msf{State}(v14) \wedge \mita{{\ttlb}
  } \wedge \msf{Paren}(v0) \wedge (\AX\AF(\exists \mita{v13}\\ . \exists \mita{hostptr} . (\msf{State}(v13) \wedge \mita{struct Scsi\_Host *hostptr;} \wedge (\AX\AF(\exists \mita{v12}\\ . (\msf{State}(v12) \wedge \mita{hostptr = scsi\_host\_hn\_get(hostno);} \wedge (\AX\AF((\exists \mita{v7}\\ . (\msf{State}(v7) \wedge \mita{if (hostptr == NULL) } \wedge (\AX((\msf{TrueBranch} \rightarrow (\exists \mita{v6} . \exists \mita{v4}\\ . (\msf{State}(v6) \wedge \mita{{\ttlb}
  } \wedge \msf{Paren}(v4) \wedge (\AX\AF(\exists \mita{v5} . (\msf{State}(v5)\\ \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v4))))))) \wedge (\msf{FalseBranch} \rightarrow \msf{false}) \wedge (\msf{After} \rightarrow (\AF((\exists \mita{v2} . (\msf{State}(v2) \wedge \mita{scsi\_host\_put(hostptr);}\\ \wedge (\AX\AF(\exists \mita{v1} . (\msf{State}(v1) \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v0)))))) \vee ((\neg (\exists \mita{v3}\\ . (\msf{State}(v3) \wedge \mita{scsi\_host\_put(hostptr);}))) \wedge (\AF(\exists \mita{v1} . (\msf{State}(v1)\\ \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v0)))))))))))) \vee ((\neg (\exists \mita{v11} . (\msf{State}(v11) \wedge \mita{if (hostptr == NULL) }\\ \wedge (\AX((\msf{TrueBranch} \rightarrow (\exists \mita{v10} . \exists \mita{v8} . (\msf{State}(v10) \wedge \mita{{\ttlb}
  } \wedge \msf{Paren}(v8)\\ \wedge (\AX\AF(\exists \mita{v9} . (\msf{State}(v9) \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v8))))))) \wedge (\msf{FalseBranch}\\ \rightarrow \msf{false}) \wedge \msf{true}))))) \wedge (\AF((\exists \mita{v2} . (\msf{State}(v2) \wedge \mita{scsi\_host\_put(hostptr);} \wedge (\AX\AF(\exists \mita{v1}\\ . (\msf{State}(v1) \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v0)))))) \vee ((\neg (\exists \mita{v3} . (\msf{State}(v3)\\ \wedge \mita{scsi\_host\_put(hostptr);}))) \wedge (\AF(\exists \mita{v1} . (\msf{State}(v1) \wedge \mita{
{\ttrb}}\\ \wedge \msf{Paren}(v0))))))))))))))))))))
\end{array}\]

\begin{quote}\begin{verbatim}

@@
@@

proc_info_func(...) {
  <...
    
(
    E->host_no == hostno
|
    hostno
)
  ...>
}
\end{verbatim}\end{quote}

\[\begin{array}{l}
\exists \mita{v4} . (\msf{State}(v4) \wedge \mita{proc\_info\_func(...) } \wedge (\AX(\exists \mita{v3} . \exists \mita{v0} . (\msf{State}(v3)\\ \wedge \mita{{\ttlb}
  } \wedge \msf{Paren}(v0) \wedge (\AX\A[((\exists \mita{v2} . (\msf{State}(v2) \wedge (\exists \mita{hostno}\\ . \exists \mita{E} . \mita{
(
E-\mth{>}host\_no == hostno
|
hostno
)}))) \vee (\neg (\exists \mita{v2} . (\msf{State}(v2)\\ \wedge (\exists \mita{hostno} . \exists \mita{E} . \mita{
(
E-\mth{>}host\_no == hostno
|
hostno
)}))))) \U \exists \mita{v1}\\ . (\msf{State}(v1) \wedge \mita{
{\ttrb}} \wedge \msf{Paren}(v0))]
)))))
\end{array}\]

\end{document}

// ---------------------------------------------------------------------------
// Spacing (include comments) isomorphisms
// ---------------------------------------------------------------------------
// They are handled at lex time


// ---------------------------------------------------------------------------
// Dataflow isomorphisms
// ---------------------------------------------------------------------------
// copy propagation
// assignments

// ---------------------------------------------------------------------------
// Iso-by-absence (optional qualifier, storage, sign, cast) isomorphisms
// ---------------------------------------------------------------------------
// Some of them are handled in pattern.ml and transformation.ml.

// Some of them handled here.

Declaration
@@ identifier Z; @@
int Z; => signed int Z;


// ---------------------------------------------------------------------------
// Typedef isomorphisms
// ---------------------------------------------------------------------------
// todo: should be handled in engine/

// ---------------------------------------------------------------------------
// Arithmetic isomorphisms
// ---------------------------------------------------------------------------
//todo: require side-effect free expression

Expression
@@ expression X, Y; @@
X + Y <=> Y + X

// ---------------------------------------------------------------------------
// Increment isomorphisms
// ---------------------------------------------------------------------------

// equivalences between i++, +=1, ...


// ---------------------------------------------------------------------------
// Boolean isomorphisms
// ---------------------------------------------------------------------------


Expression
@@ int X; @@
X == 0 <=> !X <=> 0 == X

Expression
@@ expression X; @@
X != 0 <=> 0 != X => X


// ---------------------------------------------------------------------------
// Pointer isomorphisms
// ---------------------------------------------------------------------------

Expression
@@ expression *X; @@
X == NULL <=> !X <=> NULL == X

// pointer arithmetic equivalences


// ---------------------------------------------------------------------------
// Statement isomorphisms
// ---------------------------------------------------------------------------

// ----------------
// If
// ----------------

Statement
@@
int X;
statement S1, S2;
@@
if (X) S1 else S2 => if (X != 0) S1 else S2

Statement
@@
int X;
statement S;
@@
if (X) S => if (X != 0) S <=> if (0 != X) S


Statement
@@
expression X;
statement S1, S2;
@@
if (X) S1 else S2 <=> if (!X) S2 else S1


// pad: does not work well. cf when use with rule9.cocci.
// Statement
// @@
// expression X;
// statement S;
// @@
// if (X) { S } <=>/ if (X) S


// if (X) Y else Z <=> X ? Y : Z  sometimes.

// ----------------
// Loops
// ----------------

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
Declaration
@@
type T;
identifier Z;
@@
T Z = ...; <=> T Z;



// ---------------------------------------------------------------------------
// Branch (or compound) isomorphisms
// ---------------------------------------------------------------------------
// maybe a cocci patch should require something that looks like what is on
// the left above to occur in a if or while

Statement
@@ expression E; @@
{ ... return E; } => return E;

// Redundant because 'E' subsume (unify) '...'
//{ ... return ...; } => return ...;

//pad: redundant ? 
//Statement
//@@ expression E; @@
//{ return E; } => return E;



// ---------------------------------------------------------------------------
// Declaration isomorphisms
// ---------------------------------------------------------------------------

// handled in engine/ ?
// int i,j,k; <=> int i; int j; int k;
 

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//Expression
//@@ expression E; @@
// E => (E)
//// E => ((E))

// todo: isomorphism avec les () around ? cf sizeof 3.
// (E) => E    with some conditions.


// ---------------------------------------------------------------------------
// Pointer/Array isomorphisms
// ---------------------------------------------------------------------------

// pointer arithmetic equivalences
// a + x <=> a[x]

// ---------------------------------------------------------------------------
// Pointer/Field isomorphisms
// ---------------------------------------------------------------------------

// x->f <=> *x.f

// ****************************************************************************
// Standard C isomorphisms
// ****************************************************************************

// Note: the order of the rule has some importance. As we do not do a fixpoint,
// changing the order may impact the result. For instance, if we have
//  iso1 = x+y <=> y+x   
//  iso2 = i++ <=> i=i+1; 
// if 
//   in SP we have i++; 
//   in C  we have i=1+i;
// Does the SP match the C ? 
//  - Yes if iso2 precede iso1 in this file, 
//  - No otherwise.


// ---------------------------------------------------------------------------
// Spacing (include comments) isomorphisms
// ---------------------------------------------------------------------------
// They are handled at lex time

// ---------------------------------------------------------------------------
// Dataflow isomorphisms
// ---------------------------------------------------------------------------
// copy propagation
// assignments
// TODO in engine/

// ---------------------------------------------------------------------------
// Iso-by-absence (optional qualifier, storage, sign, cast) isomorphisms
// ---------------------------------------------------------------------------
// Some of them are handled in pattern.ml and transformation.ml.
// Some of them handled here.


//TODO optional cast so that 
// chip = (ak4117_t *)snd_magic_kcalloc(ak4117_t, 0, GFP_KERNEL);
//  also match 
// - X = snd_magic_kcalloc(T, 0, C)
// For the moment because the iso is (T) E => E and not <=>, it forces
// us to rewrite the SP as  
//  X = (T) snd_magic_kcalloc(T, 0, C)

Expression
@@
expression E;
pure type T;
@@

// in the following, the space at the beginning of the line is very important!
 (T)E => E

// it makes obsolete the following old iso: 
// Expression
// @@
// expression E1, E2;
// expression list args;
// type T;
// @@
// 
// E1 = (T) E2(args) => E1 = E2(args)


Type
@@ @@
int => signed int

Type
@@ @@
unsigned => unsigned int

Type
@@ @@
signed => signed int


// ---------------------------------------------------------------------------
// Field isomorphisms
// ---------------------------------------------------------------------------
// Dereferences


// Those iso were introduced for the 'generic program matching' paper, 
// with sgrep. The idea is that when we want to detect bugs, 
// we want to detect something like  free(X) ... *X  
// meaning that you try to access something that have been freed. 
// But *X is not the only way to deference X, there is also 
// X->fld,  hence those iso. 

Expression
@@
expression E;
identifier fld;
@@

*E => E->fld

Expression
@@
expression E;
identifier fld;
@@

*E => (E)->fld

Expression
@@
expression E,E1;
@@

*E => E[E1]

// ---------------------------------------------------------------------------
// Typedef isomorphisms
// ---------------------------------------------------------------------------
// handled in engine/


// ---------------------------------------------------------------------------
// Boolean isomorphisms
// ---------------------------------------------------------------------------

Expression
@@ int X; @@
X == 0 <=> !X <=> 0 == X

Expression
@@ expression X; @@
X != 0 <=> 0 != X => X

Expression
@@ expression X; @@
X != NULL <=> NULL != X => X


Expression
@@ expression X,Y; @@
X | Y <=> Y | X

// ---------------------------------------------------------------------------
// Arithmetic isomorphisms
// ---------------------------------------------------------------------------
//todo: require side-effect free expression

Expression
@@ expression X, Y; @@
X + Y <=> Y + X

// ---------------------------------------------------------------------------
// Increment isomorphisms
// ---------------------------------------------------------------------------

// equivalences between i++, +=1, etc
// note: there is an addition in this SP.
Statement
@@ identifier i; @@
i++; <=> ++i; <=> i+=1; <=> i=i+1;

// I would like to avoid the following rule, but we cant transform a ++i
// in i++ everywhere. We can do it only when the instruction is alone,
// such as there is not stuff around it (not as in x = i++) That's why in
// the previous iso, we have explicitely force the i++ do be alone with
// the ';' But unfortunately in the last expression of the for there is
// no ';' so the previous rule cannot be applied, hence this special
// case.

Statement
@@ expression X, Y; statement S; identifier i; @@
for(X;Y;i++) S <=> for(X;Y;++i) S


// ---------------------------------------------------------------------------
// Pointer isomorphisms
// ---------------------------------------------------------------------------

Expression
@@ expression *X; @@
X == NULL <=> !X <=> NULL == X

// pointer arithmetic equivalences


// ---------------------------------------------------------------------------
// Statement isomorphisms
// ---------------------------------------------------------------------------

// ----------------
// If
// ----------------

Statement
@@
int X;
statement S1, S2;
@@
if (X) S1 else S2 => if (X != 0) S1 else S2

Statement
@@
int X;
statement S;
@@
if (X) S => if (X != 0) S <=> if (0 != X) S


Statement
@@
expression X;
statement S1, S2;
@@
if (X) S1 else S2 <=> if (!X) S2 else S1

Statement
@@
expression E;
statement S1;
pure statement S2;
@@

if (E) S1 else S2 => if (E) S1

// pad: does not work well. cf when use with rule9.cocci.
// Statement
// @@
// expression X;
// statement S;
// @@
// if (X) { S } <=>/ if (X) S


// if (X) Y else Z <=> X ? Y : Z  sometimes.

// ----------------
// Loops
// ----------------

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
Declaration
@@
type T;
identifier Z;
@@
T Z = ...; <=> T Z;

// ---------------------------------------------------------------------------
// Branch (or compound) isomorphisms
// ---------------------------------------------------------------------------
// maybe a cocci patch should require something that looks like what is on
// the left above to occur in a if or while

//Statement
//@@ expression E; @@
//{ ... return E; } => { return E; } => return E;

//Statement
//@@ @@
//{ ... return ...; } => return ...;
//Statement
//@@ @@
//{ return ...; } => return ...;
//Statement
//@@ @@
//{ ... return; } => return;
//Statement
//@@ @@
//{ return; } => return;
//Statement
//@@ @@
//{ ... break; } => break;
//Statement
//@@ @@
//{ break; } => break;
//Statement
//@@ @@
//{ ... continue; } => continue;
//Statement
//@@ @@
//{ continue; } => continue;
//Statement
//@@ expression E; @@
//{ ... E; } => E;
//Statement
//@@ expression E; @@
//{ E; } => E;
// could worry that this has to be a simple statement, but this should work
// better as it allows + code on S
Statement
@@ statement S; @@
{ ... S } => S
Statement
@@ statement S; @@
{ ... S ... } => S
Statement
@@ statement S; @@
{ S ... } => S
Statement
@@ statement S; @@
{ S } => S
Statement
@@ @@
return ...; => return;


Expression
@@ expression E; @@

unlikely(E) => E

Expression
@@ expression E; @@

likely(E) => E

// Redundant because 'E' subsume (unify) '...'
//{ ... return ...; } => return ...;

//pad: redundant ? 
//Statement
//@@ expression E; @@
//{ return E; } => return E;



// ---------------------------------------------------------------------------
// Declaration isomorphisms
// ---------------------------------------------------------------------------

// handled in engine/ ?
// int i,j,k; <=> int i; int j; int k;
 

// ---------------------------------------------------------------------------
// Affectation/initialisation isomorphism
// ---------------------------------------------------------------------------
// TODO 'X = Y'  should also match  'type X = Y';

// ---------------------------------------------------------------------------
// 
// ---------------------------------------------------------------------------
//Expression
//@@ expression E; @@
// E => (E)
//// E => ((E))

// todo: isomorphism avec les () around ? cf sizeof 3.
// (E) => E    with some conditions.


// ---------------------------------------------------------------------------
// Pointer/Array isomorphisms
// ---------------------------------------------------------------------------

// pointer arithmetic equivalences
// a + x <=> a[x]

// ---------------------------------------------------------------------------
// Pointer/Field isomorphisms
// ---------------------------------------------------------------------------

// x->f <=> *x.f

// julia don't want a x->f<=> x.f, so have just =>

//todo: normally if E is typed metavar, should have to change 
//its type and remove the '*'. 
//doesn't work, because the terms are not equivalent, so a problem if there
//is + code
//Expression
//@@ expression E; identifier field; @@
//E->field => E.field

// pure means that either the whole field reference expression is dropped,
// or E is context code and has no attached + code
// not really... pure means matches a unitary unplussed metavariable
// but this rule doesn't work anyway

// the following doesn't work because we need to support matching
// metavariables in the metavariable declaration in iso_pattern
//Expression
//@@
//type T;
//pure T E;
//pure T *E1;
//identifier fld;
//@@
//
//E.fld => E1->fld

Expression
@@
expression E1, E2; // was pure, not sure why that's needed, not good for rule27
identifier fld;
@@

E1->fld => E1[E2].fld

// ****************************************************************************
// Put here all the Linux specific isomorphisms 
// ****************************************************************************

// Examples: many functions are equivalent/related, and one SP modifying
// such a function should also modify the equivalent/related one.


// ---------------------------------------------------------------------------
// in rule18, needed ? 
// ---------------------------------------------------------------------------
// (
// -   test_and_set_bit(ev, &bcs->event);
// |
// -   set_bit(ev, &bcs->event);
// |
// -   bcs->event |= 1 << ev; // the only case that is used

TopLevel
@@
type T;
context T E;
identifier I;
identifier fld;
expression E1;
@@

E.fld = E1; => T I = { .fld = E1, };

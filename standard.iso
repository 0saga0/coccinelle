// ---------------------------------------------------------------------------
// Note: the order of the rule have an importance. As we do not do a pointfix,
// changing the order may impact the result. For instance, if we have
// iso1 =  x+y <=> y+x  and iso2 = i++ <=> i=i+1; 
// if in SP we have i++; and in C code we have i=1+i;
// Does the SP match the C ? 
//  - Yes if iso2 precede iso1 in this file, 
//  - No otherwise.

// ---------------------------------------------------------------------------
// Spacing (include comments) isomorphisms
// ---------------------------------------------------------------------------
// They are handled at lex time

// ---------------------------------------------------------------------------
// Dataflow isomorphisms
// ---------------------------------------------------------------------------
// copy propagation
// assignments
// TODO in engine/

// ---------------------------------------------------------------------------
// Iso-by-absence (optional qualifier, storage, sign, cast) isomorphisms
// ---------------------------------------------------------------------------
// Some of them are handled in pattern.ml and transformation.ml.
// Some of them handled here.

Declaration
@@ identifier Z; @@
int Z; => signed int Z;


// ---------------------------------------------------------------------------
// Typedef isomorphisms
// ---------------------------------------------------------------------------
// TODO should be handled in engine/




// ---------------------------------------------------------------------------
// Boolean isomorphisms
// ---------------------------------------------------------------------------

Expression
@@ int X; @@
X == 0 <=> !X <=> 0 == X

Expression
@@ expression X; @@
X != 0 <=> 0 != X => X


Expression
@@ expression X,Y; @@
X | Y <=> Y | X

// ---------------------------------------------------------------------------
// Arithmetic isomorphisms
// ---------------------------------------------------------------------------
//todo: require side-effect free expression

Expression
@@ expression X, Y; @@
X + Y <=> Y + X

// ---------------------------------------------------------------------------
// Increment isomorphisms
// ---------------------------------------------------------------------------

// equivalences between i++, +=1, etc
// note: there is an addition in this SP.
Statement
@@ identifier i; @@
i++; <=> ++i; <=> i+=1; <=> i=i+1;

// I would like to avoid the following rule, but
// we cant transform a ++i in i++ everywhere. 
// We can do it only when the instruction is alone, such as
// there is not stuff around it (not as in x = i++)
// That's why in the previous iso, we have explicitely force
// the i++ do be alone with the ';'
// But unfortunately in the last expression of the for there is no ';'
// so the previous rule cannot be applied, and this special case. 
Statement
@@ expression X, Y; statement S; identifier i; @@
for(X;Y;i++) S <=> for(X;Y;++i) S


// ---------------------------------------------------------------------------
// Pointer isomorphisms
// ---------------------------------------------------------------------------

Expression
@@ expression *X; @@
X == NULL <=> !X <=> NULL == X

// pointer arithmetic equivalences


// ---------------------------------------------------------------------------
// Statement isomorphisms
// ---------------------------------------------------------------------------

// ----------------
// If
// ----------------

Statement
@@
int X;
statement S1, S2;
@@
if (X) S1 else S2 => if (X != 0) S1 else S2

Statement
@@
int X;
statement S;
@@
if (X) S => if (X != 0) S <=> if (0 != X) S


Statement
@@
expression X;
statement S1, S2;
@@
if (X) S1 else S2 <=> if (!X) S2 else S1


// pad: does not work well. cf when use with rule9.cocci.
// Statement
// @@
// expression X;
// statement S;
// @@
// if (X) { S } <=>/ if (X) S


// if (X) Y else Z <=> X ? Y : Z  sometimes.

// ----------------
// Loops
// ----------------

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
Declaration
@@
type T;
identifier Z;
@@
T Z = ...; <=> T Z;



// ---------------------------------------------------------------------------
// Branch (or compound) isomorphisms
// ---------------------------------------------------------------------------
// maybe a cocci patch should require something that looks like what is on
// the left above to occur in a if or while

//Statement
//@@ expression E; @@
//{ ... return E; } => { return E; } => return E;

Statement
@@ @@
{ ... return ...; } => { return ...; } => return ...;
Statement
@@ @@
{ ... return; } => { return; } => return;
Statement
@@ @@
{ ... break; } => { break; } => break;
Statement
@@ @@
{ ... continue; } => { continue; } => continue;
Statement
@@ expression E; @@
{ ... E; } => { E; } => E;

// Redundant because 'E' subsume (unify) '...'
//{ ... return ...; } => return ...;

//pad: redundant ? 
//Statement
//@@ expression E; @@
//{ return E; } => return E;



// ---------------------------------------------------------------------------
// Declaration isomorphisms
// ---------------------------------------------------------------------------

// handled in engine/ ?
// int i,j,k; <=> int i; int j; int k;
 

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//Expression
//@@ expression E; @@
// E => (E)
//// E => ((E))

// todo: isomorphism avec les () around ? cf sizeof 3.
// (E) => E    with some conditions.


// ---------------------------------------------------------------------------
// Pointer/Array isomorphisms
// ---------------------------------------------------------------------------

// pointer arithmetic equivalences
// a + x <=> a[x]

// ---------------------------------------------------------------------------
// Pointer/Field isomorphisms
// ---------------------------------------------------------------------------

// x->f <=> *x.f

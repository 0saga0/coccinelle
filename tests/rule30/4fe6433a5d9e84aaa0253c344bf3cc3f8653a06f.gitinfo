commit 4fe6433a5d9e84aaa0253c344bf3cc3f8653a06f
Author: Alexander Viro <viro@math.psu.edu>
Date:   Tue Jun 11 00:56:24 2002 -0700

    [PATCH] (14/14) resync
    
    end_request(int) turned to end_request(req, int); all old callers
    are converted to end_request(CURRENT, value).  Now we can start
    killing CURRENT/QUEUE - end_request() was the last obstacle to
    that.

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index ae54b67..885f96c 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -983,33 +983,35 @@ static void do_stram_request(request_que
 	unsigned long len;
 
 	while (1) {
+		struct request *req;
 		if (blk_queue_empty(QUEUE))
 			return;
 
-		start = swap_start + (CURRENT->sector << 9);
-		len   = CURRENT->current_nr_sectors << 9;
+		req = CURRENT;
+		start = swap_start + (req->sector << 9);
+		len   = req->current_nr_sectors << 9;
 		if ((start + len) > swap_end) {
 			printk( KERN_ERR "stram: bad access beyond end of device: "
 					"block=%ld, count=%ld\n",
-					CURRENT->sector,
-					CURRENT->current_nr_sectors );
-			end_request( 0 );
+					req->sector,
+					req->current_nr_sectors );
+			end_request(req, 0);
 			continue;
 		}
 
-		if (CURRENT->cmd == READ) {
-			memcpy(CURRENT->buffer, start, len);
+		if (req->cmd == READ) {
+			memcpy(req->buffer, start, len);
 #ifdef DO_PROC
 			stat_swap_read += N_PAGES(len);
 #endif
 		}
 		else {
-			memcpy(start, CURRENT->buffer, len);
+			memcpy(start, req->buffer, len);
 #ifdef DO_PROC
 			stat_swap_write += N_PAGES(len);
 #endif
 		}
-		end_request( 1 );
+		end_request(req, 1);
 	}
 }
 
diff --git a/drivers/acorn/block/fd1772.c b/drivers/acorn/block/fd1772.c
index 28ead32..0174e68 100644
--- a/drivers/acorn/block/fd1772.c
+++ b/drivers/acorn/block/fd1772.c
@@ -598,7 +598,7 @@ static void fd_error(void)
 	CURRENT->errors++;
 	if (CURRENT->errors >= MAX_ERRORS) {
 		printk("fd%d: too many errors.\n", SelectedDrive);
-		end_request(0);
+		end_request(CURRENT, 0);
 	} else if (CURRENT->errors == RECALIBRATE_ERRORS) {
 		printk("fd%d: recalibrating\n", SelectedDrive);
 		if (SelectedDrive != -1)
@@ -623,23 +623,25 @@ #define	SET_IRQ_HANDLER(proc) do { Flopp
 
 static void do_fd_action(int drive)
 {
+	struct request *req;
 	DPRINT(("do_fd_action unit[drive].track=%d\n", unit[drive].track));
 
 #ifdef TRACKBUFFER
 repeat:
 
 	if (IS_BUFFERED( drive, ReqSide, ReqTrack )) {
+		req = CURRENT;
 		if (ReqCmd == READ) {
 			copy_buffer( SECTOR_BUFFER(ReqSector), ReqData );
-			if (++ReqCnt < CURRENT->current_nr_sectors) {
+			if (++ReqCnt < req->current_nr_sectors) {
 				/* read next sector */
 				setup_req_params( drive );
 				goto repeat;
 			} else {
 				/* all sectors finished */
-				CURRENT->nr_sectors -= CURRENT->current_nr_sectors;
-				CURRENT->sector += CURRENT->current_nr_sectors;
-				end_request( 1 );
+				req->nr_sectors -= req->current_nr_sectors;
+				req->sector += req->current_nr_sectors;
+				end_request(req, 1);
 				redo_fd_request();
 				return;
 			}
@@ -1022,7 +1024,7 @@ #endif
 		/* all sectors finished */
 		CURRENT->nr_sectors -= CURRENT->current_nr_sectors;
 		CURRENT->sector += CURRENT->current_nr_sectors;
-		end_request(1);
+		end_request(CURRENT, 1);
 		redo_fd_request();
 	}
 	return;
@@ -1234,7 +1236,7 @@ repeat:
 	if (!floppy->connected) {
 		/* drive not connected */
 		printk("Unknown Device: fd%d\n", drive);
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 	if (type == 0) {
@@ -1249,7 +1251,7 @@ repeat:
 		--type;
 		if (type >= NUM_DISK_TYPES) {
 			printk("fd%d: invalid disk format", drive);
-			end_request(0);
+			end_request(CURRENT, 0);
 			goto repeat;
 		}
 		floppy->disktype = &disk_type[type];
@@ -1258,7 +1260,7 @@ repeat:
 	}
 
 	if (CURRENT->sector + 1 > floppy->disktype->blocks) {
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 	/* stop deselect timer */
diff --git a/drivers/acorn/block/mfmhd.c b/drivers/acorn/block/mfmhd.c
index 2aec455..fd41fe9 100644
--- a/drivers/acorn/block/mfmhd.c
+++ b/drivers/acorn/block/mfmhd.c
@@ -512,7 +512,7 @@ #endif
 			CURRENT->sector += CURRENT->current_nr_sectors;
 			SectorsLeftInRequest -= CURRENT->current_nr_sectors;
 
-			end_request(1);
+			end_request(CURRENT, 1);
 			if (SectorsLeftInRequest) {
 				hdc63463_dataptr = (unsigned int) CURRENT->buffer;
 				Copy_buffer = CURRENT->buffer;
@@ -735,7 +735,7 @@ static void request_done(int uptodate)
 		/* Apparently worked - let's check bytes left to DMA */
 		if (hdc63463_dataleft != (PartFragRead_SectorsLeft * 256)) {
 			printk("mfm: request_done - dataleft=%d - should be %d - Eek!\n", hdc63463_dataleft, PartFragRead_SectorsLeft * 256);
-			end_request(0);
+			end_request(CURRENT, 0);
 			Busy = 0;
 		};
 		/* Potentially this means that we've done; but we might be doing
@@ -768,7 +768,7 @@ static void request_done(int uptodate)
 		DBG("request_done: returned from mfm_request\n");
 	} else {
 		printk("mfm:request_done: update=0\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		Busy = 0;
 	}
 }
@@ -930,7 +930,7 @@ #endif
 				printk("mfm%c: bad access: block=%d, count=%d, nr_sects=%ld\n", (dev >> 6)+'a',
 				       block, nsect, mfm[dev].nr_sects);
 			printk("mfm: continue 1\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			Busy = 0;
 			continue;
 		}
@@ -951,7 +951,7 @@ #endif
 
 		if (CURRENT->cmd != READ && CURRENT->cmd != WRITE) {
 			printk("unknown mfm-command %d\n", CURRENT->cmd);
-			end_request(0);
+			end_request(CURRENT, 0);
 			Busy = 0;
 			printk("mfm: continue 4\n");
 			continue;
diff --git a/drivers/block/acsi.c b/drivers/block/acsi.c
index 201988e..c35ef7f 100644
--- a/drivers/block/acsi.c
+++ b/drivers/block/acsi.c
@@ -775,7 +775,7 @@ static void bad_rw_intr( void )
 		return;
 
 	if (++CURRENT->errors >= MAX_ERRORS)
-		end_request(0);
+		end_request(CURRENT, 0);
 	/* Otherwise just retry */
 }
 
@@ -851,7 +851,7 @@ static void acsi_times_out( unsigned lon
 #ifdef DEBUG
 		printk( KERN_ERR "ACSI: too many errors.\n" );
 #endif
-		end_request(0);
+		end_request(CURRENT, 0);
 	}
 
 	redo_acsi_request();
@@ -919,7 +919,7 @@ static void do_end_requests( void )
 		CURRENT->current_nr_sectors -= CurrentNSect;
 		CURRENT->sector += CurrentNSect;
 		if (CURRENT->nr_sectors == 0)
-			end_request(1);
+			end_request(CURRENT, 1);
 	}
 	else {
 		for( i = 0; i < CurrentNReq; ++i ) {
@@ -927,7 +927,7 @@ static void do_end_requests( void )
 			CURRENT->nr_sectors -= n;
 			CURRENT->current_nr_sectors -= n;
 			CURRENT->sector += n;
-			end_request(1);
+			end_request(CURRENT, 1);
 		}
 	}
 }
@@ -986,13 +986,13 @@ #ifdef DEBUG
 		       block, block + CURRENT->nr_sectors - 1,
 		       acsi_part[dev].nr_sects);
 #endif
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 	if (acsi_info[DEVICE_NR(dev)].changed) {
 		printk( KERN_NOTICE "ad%c: request denied because cartridge has "
 				"been changed.\n", DEVICE_NR(dev)+'a' );
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 	
diff --git a/drivers/block/amiflop.c b/drivers/block/amiflop.c
index afa2f94..eb4ab17 100644
--- a/drivers/block/amiflop.c
+++ b/drivers/block/amiflop.c
@@ -1407,7 +1407,7 @@ #ifdef DEBUG
 #endif
 		block = CURRENT->sector + cnt;
 		if ((int)block > floppy->blocks) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			goto repeat;
 		}
 
@@ -1421,11 +1421,11 @@ #endif
 
 		if ((rq_data_dir(CURRENT) != READ) && (rq_data_dir(CURRENT) != WRITE)) {
 			printk(KERN_WARNING "do_fd_request: unknown command\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			goto repeat;
 		}
 		if (get_track(drive, track) == -1) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			goto repeat;
 		}
 
@@ -1439,7 +1439,7 @@ #endif
 
 			/* keep the drive spinning while writes are scheduled */
 			if (!fd_motor_on(drive)) {
-				end_request(0);
+				end_request(CURRENT, 0);
 				goto repeat;
 			}
 			/*
@@ -1462,7 +1462,7 @@ #endif
 	CURRENT->nr_sectors -= CURRENT->current_nr_sectors;
 	CURRENT->sector += CURRENT->current_nr_sectors;
 
-	end_request(1);
+	end_request(CURRENT, 1);
 	goto repeat;
 }
 
diff --git a/drivers/block/ataflop.c b/drivers/block/ataflop.c
index d47daf8..af8f966 100644
--- a/drivers/block/ataflop.c
+++ b/drivers/block/ataflop.c
@@ -634,7 +634,7 @@ static void fd_error( void )
 	CURRENT->errors++;
 	if (CURRENT->errors >= MAX_ERRORS) {
 		printk(KERN_ERR "fd%d: too many errors.\n", SelectedDrive );
-		end_request( 0 );
+		end_request(CURRENT, 0);
 	}
 	else if (CURRENT->errors == RECALIBRATE_ERRORS) {
 		printk(KERN_WARNING "fd%d: recalibrating\n", SelectedDrive );
@@ -759,7 +759,7 @@ static void do_fd_action( int drive )
 			/* all sectors finished */
 			CURRENT->nr_sectors -= CURRENT->current_nr_sectors;
 			CURRENT->sector += CURRENT->current_nr_sectors;
-			end_request( 1 );
+			end_request(CURRENT, 1);
 			redo_fd_request();
 			return;
 		    }
@@ -1166,7 +1166,7 @@ static void fd_rwsec_done1(int status)
 		/* all sectors finished */
 		CURRENT->nr_sectors -= CURRENT->current_nr_sectors;
 		CURRENT->sector += CURRENT->current_nr_sectors;
-		end_request( 1 );
+		end_request(CURRENT, 1);
 		redo_fd_request();
 	}
 	return;
@@ -1468,7 +1468,7 @@ repeat:
 	if (!UD.connected) {
 		/* drive not connected */
 		printk(KERN_ERR "Unknown Device: fd%d\n", drive );
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 		
@@ -1484,12 +1484,12 @@ repeat:
 		/* user supplied disk type */
 		if (--type >= NUM_DISK_MINORS) {
 			printk(KERN_WARNING "fd%d: invalid disk format", drive );
-			end_request( 0 );
+			end_request(CURRENT, 0);
 			goto repeat;
 		}
 		if (minor2disktype[type].drive_types > DriveType)  {
 			printk(KERN_WARNING "fd%d: unsupported disk format", drive );
-			end_request( 0 );
+			end_request(CURRENT, 0);
 			goto repeat;
 		}
 		type = minor2disktype[type].index;
@@ -1499,7 +1499,7 @@ repeat:
 	}
 	
 	if (CURRENT->sector + 1 > UDT->blocks) {
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 
diff --git a/drivers/block/paride/pcd.c b/drivers/block/paride/pcd.c
index 04dd695..dd6e2a4 100644
--- a/drivers/block/paride/pcd.c
+++ b/drivers/block/paride/pcd.c
@@ -775,7 +775,7 @@ static void do_pcd_request (request_queu
 	        ps_set_intr(do_pcd_read,0,0,nice); 
 		return;
 	    } 
-	    else end_request(0);
+	    else end_request(CURRENT, 0);
 	}
 }
 
@@ -817,7 +817,7 @@ static void pcd_start( void )
 		pcd_bufblk = -1; 
 		spin_lock_irqsave(&pcd_lock,saved_flags);
 		pcd_busy = 0;
-		end_request(0);
+		end_request(CURRENT, 0);
 		do_pcd_request(NULL);
 		spin_unlock_irqrestore(&pcd_lock,saved_flags);
 		return;
@@ -840,7 +840,7 @@ static void do_pcd_read( void )
 	pcd_transfer();
 	if (!pcd_count) {
 		spin_lock_irqsave(&pcd_lock,saved_flags);
-		end_request(1);
+		end_request(CURRENT, 1);
 		pcd_busy = 0;
 		do_pcd_request(NULL);
 		spin_unlock_irqrestore(&pcd_lock,saved_flags);
@@ -865,7 +865,7 @@ static void do_pcd_read_drq( void )
 		spin_lock_irqsave(&pcd_lock,saved_flags);
 		pcd_busy = 0;
 		pcd_bufblk = -1;
-		end_request(0);
+		end_request(CURRENT, 0);
 		do_pcd_request(NULL);
 		spin_unlock_irqrestore(&pcd_lock,saved_flags);
 		return;
diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c
index 535fa5d..2cb5c02 100644
--- a/drivers/block/paride/pd.c
+++ b/drivers/block/paride/pd.c
@@ -845,7 +845,7 @@ repeat:
 
         if ((pd_dev >= PD_DEVS) || 
 	    ((pd_block+pd_count) > pd_hd[pd_dev].nr_sects)) {
-                end_request(0);
+                end_request(CURRENT, 0);
                 goto repeat;
         }
 
@@ -857,7 +857,7 @@ repeat:
         if (pd_cmd == READ) pi_do_claimed(PI,do_pd_read);
         else if (pd_cmd == WRITE) pi_do_claimed(PI,do_pd_write);
         else {  pd_busy = 0;
-		end_request(0);
+		end_request(CURRENT, 0);
                 goto repeat;
         }
 }
@@ -867,7 +867,7 @@ static void pd_next_buf( int unit )
 {	long	saved_flags;
 
 	spin_lock_irqsave(&pd_lock,saved_flags);
-	end_request(1);
+	end_request(CURRENT, 1);
 	if (!pd_run) {  spin_unlock_irqrestore(&pd_lock,saved_flags);
 			return; 
 	}
@@ -907,7 +907,7 @@ static void do_pd_read_start( void )
 			return;
                 }
 		spin_lock_irqsave(&pd_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pd_busy = 0;
 		do_pd_request(NULL);
 		spin_unlock_irqrestore(&pd_lock,saved_flags);
@@ -931,7 +931,7 @@ static void do_pd_read_drq( void )
                         return;
                 }
 		spin_lock_irqsave(&pd_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pd_busy = 0;
 		do_pd_request(NULL);
 		spin_unlock_irqrestore(&pd_lock,saved_flags);
@@ -946,7 +946,7 @@ static void do_pd_read_drq( void )
         }
         pi_disconnect(PI);
 	spin_lock_irqsave(&pd_lock,saved_flags);
-        end_request(1);
+        end_request(CURRENT, 1);
         pd_busy = 0;
 	do_pd_request(NULL);
 	spin_unlock_irqrestore(&pd_lock,saved_flags);
@@ -973,7 +973,7 @@ static void do_pd_write_start( void )
                         return;
                 }
 		spin_lock_irqsave(&pd_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pd_busy = 0;
 		do_pd_request(NULL);
 		spin_unlock_irqrestore(&pd_lock,saved_flags);
@@ -989,7 +989,7 @@ static void do_pd_write_start( void )
                         return;
                 }
 		spin_lock_irqsave(&pd_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pd_busy = 0;
 		do_pd_request(NULL);
                 spin_unlock_irqrestore(&pd_lock,saved_flags);
@@ -1018,7 +1018,7 @@ static void do_pd_write_done( void )
                         return;
                 }
 		spin_lock_irqsave(&pd_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pd_busy = 0;
 		do_pd_request(NULL);
 		spin_unlock_irqrestore(&pd_lock,saved_flags);
@@ -1026,7 +1026,7 @@ static void do_pd_write_done( void )
         }
         pi_disconnect(PI);
 	spin_lock_irqsave(&pd_lock,saved_flags);
-        end_request(1);
+        end_request(CURRENT, 1);
         pd_busy = 0;
 	do_pd_request(NULL);
 	spin_unlock_irqrestore(&pd_lock,saved_flags);
diff --git a/drivers/block/paride/pf.c b/drivers/block/paride/pf.c
index 1f572c7..578feaa 100644
--- a/drivers/block/paride/pf.c
+++ b/drivers/block/paride/pf.c
@@ -849,7 +849,7 @@ repeat:
         pf_count = CURRENT->current_nr_sectors;
 
         if ((pf_unit >= PF_UNITS) || (pf_block+pf_count > PF.capacity)) {
-                end_request(0);
+                end_request(CURRENT, 0);
                 goto repeat;
         }
 
@@ -861,7 +861,7 @@ repeat:
         if (pf_cmd == READ) pi_do_claimed(PI,do_pf_read);
         else if (pf_cmd == WRITE) pi_do_claimed(PI,do_pf_write);
         else {  pf_busy = 0;
-		end_request(0);
+		end_request(CURRENT, 0);
                 goto repeat;
         }
 }
@@ -871,7 +871,7 @@ static void pf_next_buf( int unit )
 {	long	saved_flags;
 
 	spin_lock_irqsave(&pf_spin_lock,saved_flags);
-	end_request(1);
+	end_request(CURRENT, 1);
 	if (!pf_run) { spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
 		       return; 
 	}
@@ -912,7 +912,7 @@ static void do_pf_read_start( void )
 			return;
                 }
 		spin_lock_irqsave(&pf_spin_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pf_busy = 0;
 		do_pf_request(NULL);
 		spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
@@ -938,7 +938,7 @@ static void do_pf_read_drq( void )
                         return;
                 }
 		spin_lock_irqsave(&pf_spin_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pf_busy = 0;
 		do_pf_request(NULL);
 		spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
@@ -953,7 +953,7 @@ static void do_pf_read_drq( void )
         }
         pi_disconnect(PI);
 	spin_lock_irqsave(&pf_spin_lock,saved_flags); 
-        end_request(1);
+        end_request(CURRENT, 1);
         pf_busy = 0;
 	do_pf_request(NULL);
 	spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
@@ -979,7 +979,7 @@ static void do_pf_write_start( void )
 			return;
                 }
 		spin_lock_irqsave(&pf_spin_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pf_busy = 0;
 		do_pf_request(NULL);
 		spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
@@ -996,7 +996,7 @@ static void do_pf_write_start( void )
                         return;
                 }
 		spin_lock_irqsave(&pf_spin_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pf_busy = 0;
 		do_pf_request(NULL);
 		spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
@@ -1026,7 +1026,7 @@ static void do_pf_write_done( void )
                         return;
                 }
 		spin_lock_irqsave(&pf_spin_lock,saved_flags);
-                end_request(0);
+                end_request(CURRENT, 0);
                 pf_busy = 0;
 		do_pf_request(NULL);
 		spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
@@ -1034,7 +1034,7 @@ static void do_pf_write_done( void )
         }
         pi_disconnect(PI);
 	spin_lock_irqsave(&pf_spin_lock,saved_flags);
-        end_request(1);
+        end_request(CURRENT, 1);
         pf_busy = 0;
 	do_pf_request(NULL);
 	spin_unlock_irqrestore(&pf_spin_lock,saved_flags);
diff --git a/drivers/block/ps2esdi.c b/drivers/block/ps2esdi.c
index f4199ef..bd604ce 100644
--- a/drivers/block/ps2esdi.c
+++ b/drivers/block/ps2esdi.c
@@ -510,7 +510,7 @@ #endif
 
 	if (isa_virt_to_bus(CURRENT->buffer + CURRENT->current_nr_sectors * 512) > 16 * MB) {
 		printk("%s: DMA above 16MB not supported\n", DEVICE_NAME);
-		end_request(FAIL);
+		end_request(CURRENT, FAIL);
 	}			/* check for above 16Mb dmas */
 	else if ((DEVICE_NR(CURRENT->rq_dev) < ps2esdi_drives) &&
 	    (CURRENT->sector + CURRENT->current_nr_sectors <=
@@ -536,7 +536,7 @@ #endif
 			break;
 		default:
 			printk("%s: Unknown command\n", DEVICE_NAME);
-			end_request(FAIL);
+			end_request(CURRENT, FAIL);
 			break;
 		}		/* handle different commands */
 	}
@@ -544,7 +544,7 @@ #endif
 	else {
 		printk("Grrr. error. ps2esdi_drives: %d, %lu %lu\n", ps2esdi_drives,
 		       CURRENT->sector, ps2esdi[minor(CURRENT->rq_dev)].nr_sects);
-		end_request(FAIL);
+		end_request(CURRENT, FAIL);
 	}
 
 }				/* main strategy routine */
@@ -609,7 +609,7 @@ #endif
 	if (ps2esdi_out_cmd_blk(cmd_blk)) {
 		printk("%s: Controller failed\n", DEVICE_NAME);
 		if ((++CURRENT->errors) >= MAX_RETRIES)
-			end_request(FAIL);
+			end_request(CURRENT, FAIL);
 	}
 	/* check for failure to put out the command block */ 
 	else {
@@ -984,7 +984,7 @@ #endif
 	}
 	if(ending != -1) {
 		spin_lock_irqsave(&ps2esdi_lock, flags);
-		end_request(ending);
+		end_request(CURRENT, ending);
 		do_ps2esdi_request(BLK_DEFAULT_QUEUE(MAJOR_NR));
 		spin_unlock_irqrestore(&ps2esdi_lock, flags);
 	}
diff --git a/drivers/block/swim3.c b/drivers/block/swim3.c
index 8b430af..92180c3 100644
--- a/drivers/block/swim3.c
+++ b/drivers/block/swim3.c
@@ -329,15 +329,15 @@ #if 0
 #endif
 
 		if (CURRENT->sector < 0 || CURRENT->sector >= fs->total_secs) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		if (CURRENT->current_nr_sectors == 0) {
-			end_request(1);
+			end_request(CURRENT, 1);
 			continue;
 		}
 		if (fs->ejected) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
@@ -345,7 +345,7 @@ #endif
 			if (fs->write_prot < 0)
 				fs->write_prot = swim3_readbit(fs, WRITE_PROT);
 			if (fs->write_prot) {
-				end_request(0);
+				end_request(CURRENT, 0);
 				continue;
 			}
 		}
@@ -516,7 +516,7 @@ static void act(struct floppy_state *fs)
 		case do_transfer:
 			if (fs->cur_cyl != fs->req_cyl) {
 				if (fs->retries > 5) {
-					end_request(0);
+					end_request(CURRENT, 0);
 					fs->state = idle;
 					return;
 				}
@@ -548,7 +548,7 @@ static void scan_timeout(unsigned long d
 	out_8(&sw->intr_enable, 0);
 	fs->cur_cyl = -1;
 	if (fs->retries > 5) {
-		end_request(0);
+		end_request(CURRENT, 0);
 		fs->state = idle;
 		start_request(fs);
 	} else {
@@ -577,7 +577,7 @@ static void seek_timeout(unsigned long d
 		return;
 	}
 	printk(KERN_ERR "swim3: seek timeout\n");
-	end_request(0);
+	end_request(CURRENT, 0);
 	fs->state = idle;
 	start_request(fs);
 }
@@ -605,7 +605,7 @@ static void xfer_timeout(unsigned long d
 	CURRENT->current_nr_sectors -= s;
 	printk(KERN_ERR "swim3: timeout %sing sector %ld\n",
 	       (rq_data_dir(CURRENT)==WRITE? "writ": "read"), CURRENT->sector);
-	end_request(0);
+	end_request(CURRENT, 0);
 	fs->state = idle;
 	start_request(fs);
 }
@@ -639,7 +639,7 @@ #endif
 				printk(KERN_ERR "swim3: seen sector but cyl=ff?\n");
 				fs->cur_cyl = -1;
 				if (fs->retries > 5) {
-					end_request(0);
+					end_request(CURRENT, 0);
 					fs->state = idle;
 					start_request(fs);
 				} else {
@@ -710,7 +710,7 @@ #endif
 				printk("swim3: error %sing block %ld (err=%x)\n",
 				       rq_data_dir(CURRENT) == WRITE? "writ": "read",
 				       CURRENT->sector, err);
-				end_request(0);
+				end_request(CURRENT, 0);
 				fs->state = idle;
 			}
 		} else {
@@ -719,7 +719,7 @@ #endif
 				printk(KERN_ERR "swim3: fd dma: stat=%x resid=%d\n", stat, resid);
 				printk(KERN_ERR "  state=%d, dir=%lx, intr=%x, err=%x\n",
 				       fs->state, rq_data_dir(CURRENT), intr, err);
-				end_request(0);
+				end_request(CURRENT, 0);
 				fs->state = idle;
 				start_request(fs);
 				break;
@@ -728,7 +728,7 @@ #endif
 			CURRENT->current_nr_sectors -= fs->scount;
 			CURRENT->buffer += fs->scount * 512;
 			if (CURRENT->current_nr_sectors <= 0) {
-				end_request(1);
+				end_request(CURRENT, 1);
 				fs->state = idle;
 			} else {
 				fs->req_sector += fs->scount;
diff --git a/drivers/block/swim_iop.c b/drivers/block/swim_iop.c
index a25129d..ad0a730 100644
--- a/drivers/block/swim_iop.c
+++ b/drivers/block/swim_iop.c
@@ -100,7 +100,7 @@ static char *drive_names[7] = {
 
 int swimiop_init(void);
 static void swimiop_init_request(struct swim_iop_req *);
-static int swimiop_send_request(struct swim_iop_req *);
+static int swimiop_send_request(CURRENT, struct swim_iop_req *);
 static void swimiop_receive(struct iop_msg *, struct pt_regs *);
 static void swimiop_status_update(int, struct swim_drvstatus *);
 static int swimiop_eject(struct floppy_state *fs);
@@ -171,7 +171,7 @@ int swimiop_init(void)
 		swimiop_init_request(&req);
 		cmd->code = CMD_STATUS;
 		cmd->drive_num = i + 1;
-		if (swimiop_send_request(&req) != 0) continue;
+		if (swimiop_send_request(CURRENT, &req) != 0) continue;
 		while (!req.complete);
 		if (cmd->error != 0) {
 			printk(KERN_ERR "SWIM-IOP: probe on drive %d returned error %d\n", i, (uint) cmd->error);
@@ -204,7 +204,7 @@ static void swimiop_init_request(struct 
 	req->done = NULL;
 }
 
-static int swimiop_send_request(struct swim_iop_req *req)
+static int swimiop_send_request(CURRENT, struct swim_iop_req *req)
 {
 	unsigned long cpu_flags;
 	int err;
@@ -319,7 +319,7 @@ static int swimiop_eject(struct floppy_s
 	swimiop_init_request(&req);
 	cmd->code = CMD_EJECT;
 	cmd->drive_num = fs->drive_num;
-	err = swimiop_send_request(&req);
+	err = swimiop_send_request(CURRENT, &req);
 	if (err) {
 		release_drive(fs);
 		return err;
@@ -523,12 +523,12 @@ static void fd_request_complete(struct s
 	fs->state = idle;
 	if (cmd->error) {
 		printk(KERN_ERR "SWIM-IOP: error %d on read/write request.\n", cmd->error);
-		end_request(0);
+		end_request(CURRENT, 0);
 	} else {
 		CURRENT->sector += cmd->num_blocks;
 		CURRENT->current_nr_sectors -= cmd->num_blocks;
 		if (CURRENT->current_nr_sectors <= 0) {
-			end_request(1);
+			end_request(CURRENT, 1);
 			return;
 		}
 	}
@@ -540,7 +540,7 @@ static void fd_request_timeout(unsigned 
 	struct floppy_state *fs = (struct floppy_state *) data;
 
 	fs->timeout_pending = 0;
-	end_request(0);
+	end_request(CURRENT, 0);
 	fs->state = idle;
 }
 
@@ -568,15 +568,15 @@ #if 0
 #endif
 
 		if (CURRENT->sector < 0 || CURRENT->sector >= fs->total_secs) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		if (CURRENT->current_nr_sectors == 0) {
-			end_request(1);
+			end_request(CURRENT, 1);
 			continue;
 		}
 		if (fs->ejected) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
@@ -586,7 +586,7 @@ #endif
 
 		if (CURRENT->cmd == WRITE) {
 			if (fs->write_prot) {
-				end_request(0);
+				end_request(CURRENT, 0);
 				continue;
 			}
 			cmd->code = CMD_WRITE;
@@ -599,8 +599,8 @@ #endif
 		cmd->first_block = CURRENT->sector;
 		cmd->num_blocks = CURRENT->current_nr_sectors;
 
-		if (swimiop_send_request(&req)) {
-			end_request(0);
+		if (swimiop_send_request(CURRENT, &req)) {
+			end_request(CURRENT, 0);
 			continue;
 		}
 
diff --git a/drivers/block/xd.c b/drivers/block/xd.c
index d8c31e7..bca8cd4 100644
--- a/drivers/block/xd.c
+++ b/drivers/block/xd.c
@@ -306,7 +306,7 @@ static void do_xd_request (request_queue
 					break;
 			}
 		}
-		end_request(code);	/* wrap up, 0 = fail, 1 = success */
+		end_request(CURRENT, code);	/* wrap up, 0 = fail, 1 = success */
 	}
 }
 
diff --git a/drivers/block/z2ram.c b/drivers/block/z2ram.c
index 2df97e2..4a862df 100644
--- a/drivers/block/z2ram.c
+++ b/drivers/block/z2ram.c
@@ -89,14 +89,14 @@ do_z2_request( request_queue_t * q )
 	    printk( KERN_ERR DEVICE_NAME ": bad access: block=%lu, count=%u\n",
 		CURRENT->sector,
 		CURRENT->current_nr_sectors);
-	    end_request( FALSE );
+	    end_request(CURRENT, FALSE);
 	    continue;
 	}
 
 	if ( ( rq_data_dir(CURRENT) != READ ) && ( rq_data_dir(CURRENT) != WRITE ) )
 	{
 	    printk( KERN_ERR DEVICE_NAME ": bad command: %ld\n", rq_data_dir(CURRENT) );
-	    end_request( FALSE );
+	    end_request(CURRENT, FALSE);
 	    continue;
 	}
 
@@ -118,7 +118,7 @@ do_z2_request( request_queue_t * q )
 	    len -= size;
 	}
 
-	end_request( TRUE );
+	end_request(CURRENT, TRUE);
     }
 }
 
diff --git a/drivers/cdrom/aztcd.c b/drivers/cdrom/aztcd.c
index f805867..03e0f80 100644
--- a/drivers/cdrom/aztcd.c
+++ b/drivers/cdrom/aztcd.c
@@ -1598,21 +1598,21 @@ #ifdef AZT_TEST
 #endif
 	if (DiskInfo.audio) {
 		printk("aztcd: Error, tried to mount an Audio CD\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		return;
 	}
 	azt_transfer_is_active = 1;
 	while (current_valid()) {
 		azt_transfer();
 		if (CURRENT->nr_sectors == 0) {
-			end_request(1);
+			end_request(CURRENT, 1);
 		} else {
 			azt_buf_out = -1;	/* Want to read a block not in buffer */
 			if (azt_state == AZT_S_IDLE) {
 				if ((!aztTocUpToDate) || aztDiskChanged) {
 					if (aztUpdateToc() < 0) {
 						while (current_valid())
-							end_request(0);
+							end_request(CURRENT, 0);
 						break;
 					}
 				}
@@ -2009,7 +2009,7 @@ #endif
 				loop_ctl = 0;
 			}
 			if (current_valid())
-				end_request(0);
+				end_request(CURRENT, 0);
 			AztTries = 5;
 		}
 		azt_error = 0;
@@ -2058,7 +2058,7 @@ #endif
 						aztDiskChanged = 1;
 						aztTocUpToDate = 0;
 						azt_invalidate_buffers();
-						end_request(0);
+						end_request(CURRENT, 0);
 						printk
 						    ("aztcd: Disk Changed or Not Ready 1 - Unmount Disk!\n");
 					}
@@ -2072,7 +2072,7 @@ #endif
 				aztTocUpToDate = 0;
 				printk
 				    ("aztcd: Disk Changed or Not Ready 2 - Unmount Disk!\n");
-				end_request(0);
+				end_request(CURRENT, 0);
 				printk((st & AST_DOOR_OPEN) ?
 				       "aztcd: door open\n" :
 				       "aztcd: disk removed\n");
@@ -2118,7 +2118,7 @@ #endif
 						azt_invalidate_buffers();
 						printk
 						    ("aztcd: Disk Changed or Not Ready 3 - Unmount Disk!\n");
-						end_request(0);
+						end_request(CURRENT, 0);
 					}
 				} else
 					break;
@@ -2294,7 +2294,7 @@ #endif
 						azt_read_count = 0;
 						azt_state = AZT_S_STOP;
 						loop_ctl = 1;
-						end_request(1);	/*should we have here (1) or (0)? */
+						end_request(CURRENT, 1);	/*should we have here (1) or (0)? */
 					} else {
 						if (azt_read_mode ==
 						    AZT_MODE_2) {
@@ -2339,7 +2339,7 @@ #endif
 						azt_transfer();
 						if (CURRENT->nr_sectors ==
 						    0)
-							end_request(1);
+							end_request(CURRENT, 1);
 						else
 							break;
 					}
@@ -2414,7 +2414,7 @@ #endif
 				azt_invalidate_buffers();
 				printk
 				    ("aztcd: Disk Changed or Not Ready 4 - Unmount Disk!\n");
-				end_request(0);
+				end_request(CURRENT, 0);
 			}
 
 #ifdef AZT_TEST3
diff --git a/drivers/cdrom/cdu31a.c b/drivers/cdrom/cdu31a.c
index 2040f93..b57c880 100644
--- a/drivers/cdrom/cdu31a.c
+++ b/drivers/cdrom/cdu31a.c
@@ -1606,7 +1606,7 @@ #endif
 
 		if (!sony_toc_read) {
 			printk("CDU31A: TOC not read\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			goto cdu31a_request_startover;
 		}
 
@@ -1620,14 +1620,14 @@ #endif
 				if ((block / 4) >= sony_toc.lead_out_start_lba) {
 					printk
 						("CDU31A: Request past end of media\n");
-					end_request(0);
+					end_request(CURRENT, 0);
 					goto cdu31a_request_startover;
 				}
 				if (((block + nblock) / 4) >=
 				    sony_toc.lead_out_start_lba) {
 					printk
 						("CDU31A: Request past end of media\n");
-					end_request(0);
+					end_request(CURRENT, 0);
 					goto cdu31a_request_startover;
 				}
 
@@ -1638,7 +1638,7 @@ #endif
 
 				if (!sony_toc_read) {
 					printk("CDU31A: TOC not read\n");
-					end_request(0);
+					end_request(CURRENT, 0);
 					goto cdu31a_request_startover;
 				}
 
@@ -1647,7 +1647,7 @@ #endif
 				if (sony_blocks_left == 0) {
 					if (start_request
 					    (block / 4, CDU31A_READAHEAD / 4, 0)) {
-						end_request(0);
+						end_request(CURRENT, 0);
 						goto cdu31a_request_startover;
 					}
 				}
@@ -1663,14 +1663,14 @@ #endif
 					abort_read();
 					if (!sony_toc_read) {
 						printk("CDU31A: TOC not read\n");
-						end_request(0);
+						end_request(CURRENT, 0);
 						goto cdu31a_request_startover;
 					}
 					if (start_request
 					    (block / 4, CDU31A_READAHEAD / 4, 0)) {
 						printk
 							("CDU31a: start request failed\n");
-						end_request(0);
+						end_request(CURRENT, 0);
 						goto cdu31a_request_startover;
 					}
 				}
@@ -1679,7 +1679,7 @@ #endif
 						res_reg, &res_size);
 				if (res_reg[0] == 0x20) {
 					if (num_retries > MAX_CDU31A_RETRIES) {
-						end_request(0);
+						end_request(CURRENT, 0);
 						goto cdu31a_request_startover;
 					}
 
@@ -1696,12 +1696,12 @@ #endif
 					}
 					goto try_read_again;
 				} else {
-					end_request(1);
+					end_request(CURRENT, 1);
 				}
 				break;
 
 			case WRITE:
-				end_request(0);
+				end_request(CURRENT, 0);
 				break;
 
 			default:
diff --git a/drivers/cdrom/cm206.c b/drivers/cdrom/cm206.c
index 8d4935a..2b9cf52 100644
--- a/drivers/cdrom/cm206.c
+++ b/drivers/cdrom/cm206.c
@@ -864,7 +864,7 @@ static void do_cm206_request(request_que
 		if (CURRENT->cmd != READ) {
 			debug(("Non-read command %d on cdrom\n",
 			       CURRENT->cmd));
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		spin_unlock_irq(q->queue_lock);
@@ -895,7 +895,7 @@ static void do_cm206_request(request_que
 			}
 		}
 		spin_lock_irq(q->queue_lock);
-		end_request(!error);
+		end_request(CURRENT, !error);
 	}
 }
 
diff --git a/drivers/cdrom/gscd.c b/drivers/cdrom/gscd.c
index 4de8844..dcca0b0 100644
--- a/drivers/cdrom/gscd.c
+++ b/drivers/cdrom/gscd.c
@@ -292,13 +292,13 @@ static void __do_gscd_request(unsigned l
 
 	if (CURRENT->cmd != READ) {
 		printk("GSCD: bad cmd %p\n", CURRENT->cmd);
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 
 	if (dev != 0) {
 		printk("GSCD: this version supports only one device\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 
@@ -307,7 +307,7 @@ static void __do_gscd_request(unsigned l
 	/* if we satisfied the request from the buffer, we're done. */
 
 	if (CURRENT->nr_sectors == 0) {
-		end_request(1);
+		end_request(CURRENT, 1);
 		goto repeat;
 	}
 #ifdef GSCD_DEBUG
@@ -337,11 +337,11 @@ static void gscd_read_cmd(void)
 	cmd_status();
 	if (disk_state & (ST_NO_DISK | ST_DOOR_OPEN)) {
 		printk("GSCD: no disk or door open\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 	} else {
 		if (disk_state & ST_INVALID) {
 			printk("GSCD: disk invalid\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 		} else {
 			gscd_bn = -1;	/* purge our buffer */
 			block = CURRENT->sector / 4;
@@ -360,7 +360,7 @@ #endif
 
 			gscd_bn = CURRENT->sector / 4;
 			gscd_transfer();
-			end_request(1);
+			end_request(CURRENT, 1);
 		}
 	}
 	SET_TIMER(__do_gscd_request, 1);
diff --git a/drivers/cdrom/mcd.c b/drivers/cdrom/mcd.c
index 3e4e293..fd5d2ef 100644
--- a/drivers/cdrom/mcd.c
+++ b/drivers/cdrom/mcd.c
@@ -622,14 +622,14 @@ static void do_mcd_request(request_queue
 	while (current_valid()) {
 		mcd_transfer();
 		if (CURRENT->nr_sectors == 0) {
-			end_request(1);
+			end_request(CURRENT, 1);
 		} else {
 			mcd_buf_out = -1;	/* Want to read a block not in buffer */
 			if (mcd_state == MCD_S_IDLE) {
 				if (!tocUpToDate) {
 					if (updateToc() < 0) {
 						while (current_valid())
-							end_request(0);
+							end_request(CURRENT, 0);
 						break;
 					}
 				}
@@ -694,7 +694,7 @@ #endif
 					goto ret;
 				}
 				if (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				McdTries = MCD_RETRY_ATTEMPTS;
 			}
 		}
@@ -751,7 +751,7 @@ set_mode_immediately:
 				       "mcd: disk removed\n");
 				mcd_state = MCD_S_IDLE;
 				while (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				goto out;
 			}
 			outb(MCMD_SET_MODE, MCDPORT(0));
@@ -785,7 +785,7 @@ read_immediately:
 				       "mcd: disk removed\n");
 				mcd_state = MCD_S_IDLE;
 				while (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				goto out;
 			}
 
@@ -826,7 +826,7 @@ #endif
 					break;
 				}
 				if (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				McdTries = 5;
 			}
 			mcd_state = MCD_S_START;
@@ -853,7 +853,7 @@ #endif
 				while (current_valid()) {
 					mcd_transfer();
 					if (CURRENT->nr_sectors == 0)
-						end_request(1);
+						end_request(CURRENT, 1);
 					else
 						break;
 				}
diff --git a/drivers/cdrom/mcdx.c b/drivers/cdrom/mcdx.c
index eac2241..5a782d5 100644
--- a/drivers/cdrom/mcdx.c
+++ b/drivers/cdrom/mcdx.c
@@ -575,14 +575,14 @@ void do_mcdx_request(request_queue_t * q
 		xwarn("do_request(): bad device: %s\n",
 		      kdevname(CURRENT->rq_dev));
 		xtrace(REQUEST, "end_request(0): bad device\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		return;
 	}
 
 	if (stuffp->audio) {
 		xwarn("do_request() attempt to read from audio cd\n");
 		xtrace(REQUEST, "end_request(0): read from audio\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		return;
 	}
 
@@ -592,7 +592,7 @@ void do_mcdx_request(request_queue_t * q
 	if (CURRENT->cmd != READ) {
 		xwarn("do_request(): non-read command to cd!!\n");
 		xtrace(REQUEST, "end_request(0): write\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		return;
 	}
 	else {
@@ -606,18 +606,18 @@ void do_mcdx_request(request_queue_t * q
 					  CURRENT->nr_sectors);
 
 			if (i == -1) {
-				end_request(0);
+				end_request(CURRENT, 0);
 				goto again;
 			}
 			CURRENT->sector += i;
 			CURRENT->nr_sectors -= i;
 			CURRENT->buffer += (i * 512);
 		}
-		end_request(1);
+		end_request(CURRENT, 1);
 		goto again;
 
 		xtrace(REQUEST, "end_request(1)\n");
-		end_request(1);
+		end_request(CURRENT, 1);
 	}
 
 	goto again;
diff --git a/drivers/cdrom/optcd.c b/drivers/cdrom/optcd.c
index 0b2c76f..da3a907 100644
--- a/drivers/cdrom/optcd.c
+++ b/drivers/cdrom/optcd.c
@@ -1096,7 +1096,7 @@ static void poll(unsigned long data)
 			if (transfer_is_active)
 				loop_again = 0;
 			if (current_valid())
-				end_request(0);
+				end_request(CURRENT, 0);
 			tries = 5;
 		}
 		error = 0;
@@ -1130,7 +1130,7 @@ #endif
 			if (send_cmd(COMDRVST)) {
 				state = S_IDLE;
 				while (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				return;
 			}
 			state = S_READ;
@@ -1157,7 +1157,7 @@ #endif
 					: "disk removed");
 				state = S_IDLE;
 				while (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				return;
 			}
 			if (!current_valid()) {
@@ -1212,7 +1212,7 @@ #endif
 						break;
 					}
 					if (current_valid())
-						end_request(0);
+						end_request(CURRENT, 0);
 					tries = 5;
 				}
 				state = S_START;
@@ -1248,7 +1248,7 @@ #endif
 						read_count = 0;
 						state = S_STOP;
 						loop_again = 1;
-						end_request(0);
+						end_request(CURRENT, 0);
 						break;
 					}
 					fetch_data(buf+
@@ -1278,7 +1278,7 @@ #endif
 					while (current_valid()) {
 						transfer();
 						if (CURRENT -> nr_sectors == 0)
-							end_request(1);
+							end_request(CURRENT, 1);
 						else
 							break;
 					}
@@ -1309,7 +1309,7 @@ #endif
 			if (send_cmd(COMDRVST)) {
 				state = S_IDLE;
 				while (current_valid())
-					end_request(0);
+					end_request(CURRENT, 0);
 				return;
 			}
 			state = S_STOPPING;
@@ -1350,7 +1350,7 @@ #endif
 		if (exec_cmd(COMSTOP) < 0) {
 			state = S_IDLE;
 			while (current_valid())
-				end_request(0);
+				end_request(CURRENT, 0);
 			return;
 		}
 	}
@@ -1366,7 +1366,7 @@ static void do_optcd_request(request_que
 
 	if (disk_info.audio) {
 		printk(KERN_WARNING "optcd: tried to mount an Audio CD\n");
-		end_request(0);
+		end_request(CURRENT, 0);
 		return;
 	}
 
@@ -1374,14 +1374,14 @@ static void do_optcd_request(request_que
 	while (current_valid()) {
 		transfer();	/* First try to transfer block from buffers */
 		if (CURRENT -> nr_sectors == 0) {
-			end_request(1);
+			end_request(CURRENT, 1);
 		} else {	/* Want to read a block not in buffer */
 			buf_out = NOBUF;
 			if (state == S_IDLE) {
 				/* %% Should this block the request queue?? */
 				if (update_toc() < 0) {
 					while (current_valid())
-						end_request(0);
+						end_request(CURRENT, 0);
 					break;
 				}
 				/* Start state machine */
diff --git a/drivers/cdrom/sbpcd.c b/drivers/cdrom/sbpcd.c
index bf8a8a4..937c5f4 100644
--- a/drivers/cdrom/sbpcd.c
+++ b/drivers/cdrom/sbpcd.c
@@ -4864,7 +4864,7 @@ #endif
 	blkdev_dequeue_request(req);	/* task can fuck it up         GTL  */
 
 	if (req -> sector == -1)
-		end_request(0);
+		end_request(CURRENT, 0);
 	spin_unlock_irq(q->queue_lock);
 
 	down(&ioctl_read_sem);
@@ -4906,7 +4906,7 @@ #ifdef DEBUG_GTL
 #endif
 		up(&ioctl_read_sem);
 		spin_lock_irq(q->queue_lock);
-		end_request(1);
+		end_request(CURRENT, 1);
 		goto request_loop;
 	}
 
@@ -4947,7 +4947,7 @@ #ifdef DEBUG_GTL
 #endif
 			up(&ioctl_read_sem);
 			spin_lock_irq(q->queue_lock);
-			end_request(1);
+			end_request(CURRENT, 1);
 			goto request_loop;
 		}
 	}
@@ -4963,7 +4963,7 @@ #endif
 	up(&ioctl_read_sem);
 	sbp_sleep(0);    /* wait a bit, try again */
 	spin_lock_irq(q->queue_lock);
-	end_request(0);
+	end_request(CURRENT, 0);
 	goto request_loop;
 }
 /*==========================================================================*/
diff --git a/drivers/cdrom/sjcd.c b/drivers/cdrom/sjcd.c
index 80a4719..544af74 100644
--- a/drivers/cdrom/sjcd.c
+++ b/drivers/cdrom/sjcd.c
@@ -1304,7 +1304,7 @@ #if defined( SJCD_TRACE )
 					     sjcd_next_bn);
 #endif
 					if (current_valid())
-						end_request(0);
+						end_request(CURRENT, 0);
 #if defined( SJCD_TRACE )
 					printk
 					    ("SJCD_S_DATA: pre-cmd failed: go to SJCD_S_STOP mode\n");
@@ -1378,7 +1378,7 @@ #endif
 							    nr_sectors ==
 							    0)
 								end_request
-								    (1);
+								    (CURRENT, 1);
 							else
 								break;
 						}
@@ -1473,7 +1473,7 @@ #endif
 	if (--sjcd_transfer_timeout == 0) {
 		printk("SJCD: timeout in state %d\n", sjcd_transfer_state);
 		while (current_valid())
-			end_request(0);
+			end_request(CURRENT, 0);
 		sjcd_send_cmd(SCMD_STOP);
 		sjcd_transfer_state = SJCD_S_IDLE;
 		goto ReSwitch;
@@ -1496,7 +1496,7 @@ #endif
 	while (current_valid()) {
 		sjcd_transfer();
 		if (CURRENT->nr_sectors == 0)
-			end_request(1);
+			end_request(CURRENT, 1);
 		else {
 			sjcd_buf_out = -1;	/* Want to read a block not in buffer */
 			if (sjcd_transfer_state == SJCD_S_IDLE) {
@@ -1505,7 +1505,7 @@ #endif
 						printk
 						    ("SJCD: transfer: discard\n");
 						while (current_valid())
-							end_request(0);
+							end_request(CURRENT, 0);
 						break;
 					}
 				}
diff --git a/drivers/cdrom/sonycd535.c b/drivers/cdrom/sonycd535.c
index 4d1f7af..a4c527e 100644
--- a/drivers/cdrom/sonycd535.c
+++ b/drivers/cdrom/sonycd535.c
@@ -818,7 +818,7 @@ do_cdu535_request(request_queue_t * q)
 		block = CURRENT->sector;
 		nsect = CURRENT->nr_sectors;
 		if (dev != 0) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		if(CURRENT->flags & REQ_CMD) {
@@ -830,11 +830,11 @@ do_cdu535_request(request_queue_t * q)
 				 */
 				
 				if (sony_toc->lead_out_start_lba <= (block / 4)) {
-					end_request(0);
+					end_request(CURRENT, 0);
 					return;
 				}
 				if (sony_toc->lead_out_start_lba <= ((block + nsect) / 4)) {
-					end_request(0);
+					end_request(CURRENT, 0);
 					return;
 				}
 				while (0 < nsect) {
@@ -896,7 +896,7 @@ do_cdu535_request(request_queue_t * q)
 									       status[0]);
 								sony_first_block = -1;
 								sony_last_block = -1;
-								end_request(0);
+								end_request(CURRENT, 0);
 								return;
 							}
 							if (readStatus == BAD_STATUS) {
@@ -925,11 +925,11 @@ #endif
 					CURRENT->buffer += 512;
 				}
 
-				end_request(1);
+				end_request(CURRENT, 1);
 				break;
 				
 			case WRITE:
-				end_request(0);
+				end_request(CURRENT, 0);
 				break;
 				
 			default:
diff --git a/drivers/ide/hd.c b/drivers/ide/hd.c
index c1b5800..7fd714e 100644
--- a/drivers/ide/hd.c
+++ b/drivers/ide/hd.c
@@ -378,7 +378,7 @@ static void bad_rw_intr(void)
 		return;
 	dev = DEVICE_NR(CURRENT->rq_dev);
 	if (++CURRENT->errors >= MAX_ERRORS || (hd_error & BBD_ERR)) {
-		end_request(0);
+		end_request(CURRENT, 0);
 		special_op[dev] = recalibrate[dev] = 1;
 	} else if (CURRENT->errors % RESET_FREQ == 0)
 		reset = 1;
@@ -428,7 +428,7 @@ #ifdef DEBUG
 		(unsigned long) CURRENT->buffer+512));
 #endif
 	if (CURRENT->current_nr_sectors <= 0)
-		end_request(1);
+		end_request(CURRENT, 1);
 	if (i > 0) {
 		SET_HANDLER(&read_intr);
 		return;
@@ -466,7 +466,7 @@ ok_to_write:
 	--CURRENT->current_nr_sectors;
 	CURRENT->buffer += 512;
 	if (!i || (CURRENT->bio && !SUBSECTOR(i)))
-		end_request(1);
+		end_request(CURRENT, 1);
 	if (i > 0) {
 		SET_HANDLER(&write_intr);
 		outsw(HD_DATA,CURRENT->buffer,256);
@@ -511,7 +511,7 @@ static void hd_times_out(unsigned long d
 #ifdef DEBUG
 		printk("hd%c: too many errors\n", dev+'a');
 #endif
-		end_request(0);
+		end_request(CURRENT, 0);
 	}
 	cli();
 	hd_request();
@@ -527,7 +527,7 @@ int do_special_op (unsigned int dev)
 	}
 	if (hd_info[dev].head > 16) {
 		printk ("hd%c: cannot handle device with more than 16 heads - giving up\n", dev+'a');
-		end_request(0);
+		end_request(CURRENT, 0);
 	}
 	special_op[dev] = 0;
 	return 1;
@@ -574,7 +574,7 @@ repeat:
 		else
 			printk("hd%c: bad access: block=%d, count=%d\n",
 				(minor(CURRENT->rq_dev)>>6)+'a', block, nsect);
-		end_request(0);
+		end_request(CURRENT, 0);
 		goto repeat;
 	}
 
@@ -612,7 +612,7 @@ #endif
 			break;
 		default:
 			printk("unknown hd-command\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			break;
 		}
 	}
diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index e9c5159..de201fd 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1228,7 +1228,7 @@ static void do_ftl_request(request_arg_t
 	  CURRENT->sector += CURRENT->current_nr_sectors;
 	}
 	
-	end_request((ret == 0) ? 1 : 0);
+	end_request(CURRENT, (ret == 0) ? 1 : 0);
     } while (1);
 } /* do_ftl_request */
 
diff --git a/drivers/mtd/nftlcore.c b/drivers/mtd/nftlcore.c
index a463368..bbe20a1 100644
--- a/drivers/mtd/nftlcore.c
+++ b/drivers/mtd/nftlcore.c
@@ -926,7 +926,7 @@ #endif /* CONFIG_NFTL_RW */
 	repeat: 
 		DEBUG(MTD_DEBUG_LEVEL3, "end_request(%d)\n", res);
 		spin_lock_irq(QUEUE->queue_lock);
-		end_request(res);
+		end_request(CURRENT, res);
 	}
 }
 
diff --git a/drivers/s390/block/xpram.c b/drivers/s390/block/xpram.c
index e80c8cd..b910726 100644
--- a/drivers/s390/block/xpram.c
+++ b/drivers/s390/block/xpram.c
@@ -693,7 +693,7 @@ void xpram_request(request_queue_t * que
 			static int count = 0;
 			if (count++ < 5) /* print the message at most five times */
 				PRINT_WARN(" request for unknown device\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
@@ -703,7 +703,7 @@ void xpram_request(request_queue_t * que
                 /* does request exceed size of device ? */
 		if ( XPRAM_SEC2KB(sects_to_copy) > xpram_sizes[dev_no] ) {
 			PRINT_WARN(" request past end of device\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
@@ -717,20 +717,20 @@ #if XPRAM_SEC_IN_PG != 1
                 if ( current_req->sector &  (XPRAM_SEC_IN_PG - 1) ) {
 			PRINT_WARN(" request does not start at an expanded storage page boundery\n");
 			PRINT_WARN(" referenced sector: %ld\n",current_req->sector);
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		/* Does request refere to partial expanded storage pages? */
                 if ( sects_to_copy & (XPRAM_SEC_IN_PG - 1) ) {
 			PRINT_WARN(" request referes to a partial expanded storage page\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 #endif /*  XPRAM_SEC_IN_PG != 1 */
 		/* Is request buffer aligned with kernel pages? */
 		if ( ((unsigned long)buffer) & (XPRAM_PGSIZE-1) ) {
 			PRINT_WARN(" request buffer is not aligned with kernel pages\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
@@ -768,11 +768,11 @@ #endif
 			break;
 		default:
 			/* can't happen */
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
-		if ( fault ) end_request(0);
-		else end_request(1); /* success */
+		if ( fault ) end_request(CURRENT, 0);
+		else end_request(CURRENT, 1); /* success */
 	}
 }
 
diff --git a/drivers/sbus/char/jsflash.c b/drivers/sbus/char/jsflash.c
index 45dd0c3..a2c58e1 100644
--- a/drivers/sbus/char/jsflash.c
+++ b/drivers/sbus/char/jsflash.c
@@ -213,7 +213,7 @@ static void jsfd_do_request(request_queu
 
 		dev = MINOR(req->rq_dev);
 		if (dev >= JSF_MAX || (dev & JSF_PART_MASK) >= JSF_NPART) {
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		jdp = &jsf0.dv[dev & JSF_PART_MASK];
@@ -221,31 +221,31 @@ static void jsfd_do_request(request_queu
 		offset = req->sector << 9;
 		len = req->current_nr_sectors << 9;
 		if ((offset + len) > jdp->dsize) {
-               		end_request(0);
+               		end_request(CURRENT, 0);
 			continue;
 		}
 
 		if (req->cmd == WRITE) {
 			printk(KERN_ERR "jsfd: write\n");
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 		if (req->cmd != READ) {
 			printk(KERN_ERR "jsfd: bad req->cmd %d\n", req->cmd);
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
 		if ((jdp->dbase & 0xff000000) != 0x20000000) {
 			printk(KERN_ERR "jsfd: bad base %x\n", (int)jdp->dbase);
-			end_request(0);
+			end_request(CURRENT, 0);
 			continue;
 		}
 
 /* printk("jsfd%d: read buf %p off %x len %x\n", dev, req->buffer, (int)offset, (int)len); */ /* P3 */
 		jsfd_read(req->buffer, jdp->dbase + offset, len);
 
-		end_request(1);
+		end_request(CURRENT, 1);
 	}
 }
 
diff --git a/include/linux/blk.h b/include/linux/blk.h
index 1606f78..69aa2fa 100644
--- a/include/linux/blk.h
+++ b/include/linux/blk.h
@@ -114,11 +114,9 @@ #endif /* !defined(IDE_DRIVER) */
  * If we have our own end_request, we do not want to include this mess
  */
 #ifndef LOCAL_END_REQUEST
-static inline void end_request(int uptodate)
+static inline void end_request(struct request *req, int uptodate)
 {
-	struct request *req = CURRENT;
-
-	if (end_that_request_first(req, uptodate, CURRENT->hard_cur_sectors))
+	if (end_that_request_first(req, uptodate, req->hard_cur_sectors))
 		return;
 
 	add_blkdev_randomness(major(req->rq_dev));

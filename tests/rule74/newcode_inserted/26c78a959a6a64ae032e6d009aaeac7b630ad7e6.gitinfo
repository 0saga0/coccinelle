commit 26c78a959a6a64ae032e6d009aaeac7b630ad7e6
Author: Andrew Morton <akpm@osdl.org>
Date:   Wed May 19 06:10:35 2004 -0700

    [PATCH] raid locking fix.
    
    From: Neil Brown <neilb@cse.unsw.edu.au>
    
    Fix bug #2661
    
    Raid currently calls ->unplug_fn under spin_lock_irqsave(), but unplug_fns
    can sleep.
    
    
    After a morning of scratching my head and trying to come up with some that
    does less locking, the following is the best I can come up with.  I'm not
    proud of it but it should work.
    
    If I move "nr_pending" out or rdev into the per-personality structures
    (e.g.  mirror_info), and if I had "atomic_inc_if_nonzero" I could do with
    without locking so much, but random atomic* functions don't seem trivial

diff --git a/drivers/md/multipath.c b/drivers/md/multipath.c
index 88f4c59..8f675d1 100644
--- a/drivers/md/multipath.c
+++ b/drivers/md/multipath.c
@@ -159,16 +159,25 @@ static void unplug_slaves(mddev_t *mddev
 {
 	multipath_conf_t *conf = mddev_to_conf(mddev);
 	int i;
+	unsigned long flags;
 
+	spin_lock_irqsave(&conf->device_lock, flags);
 	for (i=0; i<mddev->raid_disks; i++) {
 		mdk_rdev_t *rdev = conf->multipaths[i].rdev;
 		if (rdev && !rdev->faulty) {
 			request_queue_t *r_queue = bdev_get_queue(rdev->bdev);
 
+			atomic_inc(&rdev->nr_pending);
+			spin_unlock_irqrestore(&conf->device_lock, flags);
+
 			if (r_queue->unplug_fn)
 				r_queue->unplug_fn(r_queue);
+
+			spin_lock_irqsave(&conf->device_lock, flags);
+			atomic_dec(&rdev->nr_pending);
 		}
 	}
+	spin_unlock_irqrestore(&conf->device_lock, flags);
 }
 static void multipath_unplug(request_queue_t *q)
 {
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index bcc81ef..c600b1b 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -459,11 +459,17 @@ static void unplug_slaves(mddev_t *mddev
 	spin_lock_irqsave(&conf->device_lock, flags);
 	for (i=0; i<mddev->raid_disks; i++) {
 		mdk_rdev_t *rdev = conf->mirrors[i].rdev;
-		if (rdev && !rdev->faulty) {
+		if (rdev && atomic_read(&rdev->nr_pending)) {
 			request_queue_t *r_queue = bdev_get_queue(rdev->bdev);
 
+			atomic_inc(&rdev->nr_pending);
+			spin_unlock_irqrestore(&conf->device_lock, flags);
+
 			if (r_queue->unplug_fn)
 				r_queue->unplug_fn(r_queue);
+
+			spin_lock_irqsave(&conf->device_lock, flags);
+			atomic_dec(&rdev->nr_pending);
 		}
 	}
 	spin_unlock_irqrestore(&conf->device_lock, flags);
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index a88c56a..402edd5 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -1301,18 +1301,25 @@ static void unplug_slaves(mddev_t *mddev
 {
 	raid5_conf_t *conf = mddev_to_conf(mddev);
 	int i;
+	unsigned long flags;
 
+	spin_lock_irqsave(&conf->device_lock, flags);
 	for (i=0; i<mddev->raid_disks; i++) {
 		mdk_rdev_t *rdev = conf->disks[i].rdev;
-		if (rdev && !rdev->faulty) {
-			struct block_device *bdev = rdev->bdev;
-			if (bdev) {
-				request_queue_t *r_queue = bdev_get_queue(bdev);
-				if (r_queue && r_queue->unplug_fn)
-					r_queue->unplug_fn(r_queue);
-			}
+		if (rdev && atomic_read(&rdev->nr_pending)) {
+			request_queue_t *r_queue = bdev_get_queue(rdev->bdev);
+
+			atomic_inc(&rdev->nr_pending);
+			spin_unlock_irqrestore(&conf->device_lock, flags);
+
+			if (r_queue && r_queue->unplug_fn)
+				r_queue->unplug_fn(r_queue);
+
+			spin_lock_irqsave(&conf->device_lock, flags);
+			atomic_dec(&rdev->nr_pending);
 		}
 	}
+	spin_unlock_irqrestore(&conf->device_lock, flags);
 }
 
 static void raid5_unplug_device(request_queue_t *q)
diff --git a/drivers/md/raid6main.c b/drivers/md/raid6main.c
index 3055f2d..ceaec27 100644
--- a/drivers/md/raid6main.c
+++ b/drivers/md/raid6main.c
@@ -1461,21 +1461,27 @@ static inline void raid6_activate_delaye
 
 static void unplug_slaves(mddev_t *mddev)
 {
-	/* note: this is always called with device_lock held */
 	raid6_conf_t *conf = mddev_to_conf(mddev);
 	int i;
+	unsigned long flags;
 
+	spin_lock_irqsave(&conf->device_lock, flags);
 	for (i=0; i<mddev->raid_disks; i++) {
 		mdk_rdev_t *rdev = conf->disks[i].rdev;
-		if (rdev && !rdev->faulty) {
-			struct block_device *bdev = rdev->bdev;
-			if (bdev) {
-				request_queue_t *r_queue = bdev_get_queue(bdev);
-				if (r_queue && r_queue->unplug_fn)
-					r_queue->unplug_fn(r_queue);
-			}
+		if (rdev && atomic_read(&rdev->nr_pending)) {
+			request_queue_t *r_queue = bdev_get_queue(rdev->bdev);
+
+			atomic_inc(&rdev->nr_pending);
+			spin_unlock_irqrestore(&conf->device_lock, flags);
+
+			if (r_queue && r_queue->unplug_fn)
+				r_queue->unplug_fn(r_queue);
+
+			spin_lock_irqsave(&conf->device_lock, flags);
+			atomic_dec(&rdev->nr_pending);
 		}
 	}
+	spin_unlock_irqrestore(&conf->device_lock, flags);
 }
 
 static void raid6_unplug_device(request_queue_t *q)

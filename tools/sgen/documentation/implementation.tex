\\TODO ...\\
(see \texttt{sgen/source/README.md} for a broad overview of the workflow and dependencies)
%Some notes for later:
%\begin{itemize}
%\item Workflow graph (based on the workflow described in the source/README.md file
%\item Dependency graph (based on the dependencies described in the source/README.md file) HASSE DIAGRAM!
%\item The context rule generation makes extensive use of the AST0 visitor. Reason: abstracts away a lot of boilerplate code for accessing the components of the abstract syntax tree.
%\item Easy way to debug in \texttt{rule\_body.ml}: add \texttt{>> GT.add "debug msg" >>} in some function sequence.
%\item Generator types, in particular snapshot and the combiner type in rule body (which is probably the most complex part of the implementation). Snapshot is a snapshot of the current state during the AST traversal. This is a way to avoid a host of global variables.
%\item Rule generation is absolutely not optimised for performance!!! For instance, snapshot need not be purely functional; could have used a hashtable instead of map in snapshot, in a mutable record field. This way, there would only be one rule mapper throughout the full generation. Also, converts the rule mapper to a string list before printing; would be more efficient to directly print the rule mapper without the middle man. HOWEVER, this creates a better separation. Also, the small size of Coccinelle scripts in general means that performance is not really a problem in practice. Also, later on we might need to keep various copies of the rule map to generate split rules in other cases than disjunction.
%\item The generating mode flag (in the parser): cannot be substituted for ignore patch or match since that option means that the plus and minus tree are not processed in the same way.
%\end{itemize}




